{"/home/travis/build/npmtest/node-npmtest-nodent/test.js":"/* istanbul instrument in package npmtest_nodent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodent/lib.npmtest_nodent.js":"/* istanbul instrument in package npmtest_nodent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nodent = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nodent = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nodent/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nodent && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nodent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nodent\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nodent.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nodent.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nodent.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nodent.__dirname + '/lib.npmtest_nodent.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/nodent.js":"#!/usr/bin/env node\n\n'use strict';\n/**\n * NoDent - Asynchronous JavaScript Language extensions for Node\n *\n * AST transforms and node loader extension\n */\nvar stdJSLoader ;\nvar smCache = {} ;\nvar fs = require('fs') ;\nvar outputCode = require('./lib/output') ;\nvar parser = require('./lib/parser') ;\nvar treeSurgeon = require('./lib/arboriculture') ;\n\n// Config options used to control the run-time behaviour of the compiler\nvar config = {\n\tlog:function(msg){ console.warn(\"Nodent: \"+msg) },\t\t// Where to print errors and warnings\n\taugmentObject:false,\t\t\t\t\t\t\t\t\t// Only one has to say 'yes'\n\textension:'.njs',\t\t\t\t\t\t\t\t\t\t// The 'default' extension\n\tdontMapStackTraces:false,\t\t\t\t\t\t\t\t// Only one has to say 'no'\n\tasyncStackTrace:false,\n\tbabelTree:false,\n\tdontInstallRequireHook:false\n} ;\n\n// Code generation options, which are determined by the \"use nodent\"; directive. Specifically,\n// the (optional) portion as in \"use nodent<-option-set>\"; is used to select a compilation\n// behaviour on a file-by-file basis. There are preset option sets called \"es7\", \"promise(s)\"\n// and \"generators\" (which cannot be over-written). Others can be specified via the\n// 'setCompileOptions(name,options)' call, or via the 'nodent:{directive:{'name':{...}}}' entry in the\n// current project's package.json. In the latter's case, the name 'default' is also reserved and\n// is used for a bare 'use nodent' driective with no project-specific extension.\n// Finally, the 'use nodent' directive can be followed by a JSON encoded set of options, for example:\n//\t\t'use nodent-es7 {\"wrapAwait\":true}';\n//\t\t'use nodent {\"wrapAwait\":true,\"promise\":true}';\n//\t\t'use nodent-generators {\"parser\":{\"sourceType\":\"module\"}}';\n//\n// The order of application of these options is:\n//\t\tinitialCodeGenOpts (hard-coded)\n//\t\tnamed by the 'use nodent-OPTION', as read from the package.json\n//\t\tnamed by the 'use nodent-OPTION', as set by the setCompileOptions (or setDefaultCompileOptions)\n//\t\tset within the directive as a JSON-encoded extension\n\nvar initialCodeGenOpts = {\n    noRuntime:false,\n    lazyThenables:false,\n    es6target:false,\n    noUseDirective:false,\n\twrapAwait:null,\n\tmapStartLine:0,\n\tsourcemap:true,\n    engine:false,\n\tparser:{sourceType:'script'},\n\t$return:\"$return\",\n\t$error:\"$error\",\n\t$arguments:\"$args\",\n\t$asyncspawn:\"$asyncspawn\",\n\t$asyncbind:\"$asyncbind\",\n\tgeneratedSymbolPrefix:\"$\",\n\t$makeThenable:'$makeThenable'\n};\n\nfunction copyObj(a){\n\tvar o = {} ;\n\ta.forEach(function(b){\n\t\tif (b && typeof b==='object')\n\t\t\tfor (var k in b)\n\t\t\t\to[k] = b[k]  ;\n\t}) ;\n\treturn o ;\n};\n\nvar defaultCodeGenOpts = Object.create(initialCodeGenOpts, {es7:{value:true,writable:true,enumerable:true}}) ;\nvar optionSets = {\n\tdefault:defaultCodeGenOpts,\n\tes7:Object.create(defaultCodeGenOpts),\n\tpromise:Object.create(defaultCodeGenOpts,{\n\t\tpromises:{value:true,writable:true,enumerable:true}\n\t}),\n\tgenerator:Object.create(defaultCodeGenOpts,{\n\t\tgenerators:{value:true,writable:true,enumerable:true},\n\t\tes7:{value:false,writable:true,enumerable:true}\n\t}),\n\tengine:Object.create(defaultCodeGenOpts,{\n\t\tengine:{value:true,writable:true,enumerable:true},\n\t\tpromises:{value:true,writable:true,enumerable:true}\n\t})\n};\noptionSets.promises = optionSets.promise ;\noptionSets.generators = optionSets.generator ;\n\nfunction globalErrorHandler(err) {\n\tthrow err ;\n}\n\n/* Extract compiler options from code (either a string or AST) */\nvar useDirective = /^\\s*['\"]use\\s+nodent-?([a-zA-Z0-9]*)?(\\s*.*)?['\"]\\s*;/\nvar runtimes = require('nodent-runtime') ;\nvar $asyncbind = runtimes.$asyncbind ;\nvar $asyncspawn = runtimes.$asyncspawn ;\nvar Thenable = $asyncbind.Thenable ;\n\nfunction noLogger(){}\n\nfunction isDirective(node){\n    return node.type === 'ExpressionStatement' &&\n        (node.expression.type === 'StringLiteral' ||\n            (node.expression.type === 'Literal' && typeof node.expression.value === 'string')) ;\n}\n\nfunction parseCompilerOptions(code,log,filename) {\n    if (!log) log = console.warn.bind(console) ;\n\tvar regex, set, parseOpts = {} ;\n\tif (typeof code==\"string\") {\n\t\tif (regex = code.match(useDirective)) {\n\t\t\tset = regex[1] || 'default' ;\n\t\t}\n\t} else { // code is an AST\n\t\tfor (var i=0; i<code.body.length; i++) {\n\t\t\tif (isDirective(code.body[i].type)) {\n\t\t\t    var test = \"'\"+code.body[i].value+\"'\" ;\n\t\t\t\tif (regex = test.match(useDirective)) {\n\t\t\t\t\tset = regex[1] || 'default' ;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t    break ; // Directives should preceed all other statements\n\t\t\t}\n\t\t}\n\t}\n\tif (!regex) {\n\t    if (!defaultCodeGenOpts.noUseDirective)\n\t        return null ;\n\t    set = \"default\" ;\n\t    regex = [null,null,\"{}\"] ;\n\t}\n\tif (set) {\n\t    try {\n\t        if (!filename)\n\t            filename = require('path').resolve('.') ;\n\t        else  if (!require('fs').lstatSync(filename).isDirectory())\n\t            filename = require('path').dirname(filename) ;\n\n\t        var packagePath = require('resolve').sync('package.json',{\n\t            moduleDirectory:[''],\n\t            extensions:[''],\n\t            basedir:filename\n\t        }) ;\n\t        var packageOptions = JSON.parse(fs.readFileSync(packagePath)).nodent.directive[set] ;\n\t    } catch(ex) {\n\t        // Meh\n\t    }\n\t}\n\ttry {\n\t\tparseOpts = copyObj([optionSets[set],packageOptions,regex[2] && JSON.parse(regex[2])]);\n\t} catch(ex) {\n\t\tlog(\"Invalid literal compiler option: \"+((regex && regex[0]) || \"<no options found>\"));\n\t}\n\n\tif (parseOpts.promises || parseOpts.es7 || parseOpts.generators || parseOpts.engine) {\n\t\tif ((((parseOpts.promises || parseOpts.es7) && parseOpts.generators))) {\n\t\t\tlog(\"No valid 'use nodent' directive, assumed -es7 mode\") ;\n\t\t\tparseOpts = optionSets.es7 ;\n\t\t}\n\n\t\tif (parseOpts.generators || parseOpts.engine)\n\t\t    parseOpts.promises = true ;\n\t\tif (parseOpts.promises)\n\t\t    parseOpts.es7 = true ;\n\t\treturn parseOpts ;\n\t}\n\treturn null ; // No valid nodent options\n}\n\nfunction stripBOM(content) {\n\t// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n\t// because the buffer-to-string conversion in `fs.readFileSync()`\n\t// translates it to FEFF, the UTF-16 BOM.\n\tif (content.charCodeAt(0) === 0xFEFF) {\n\t\tcontent = content.slice(1);\n\t}\n\tif (content.substring(0,2) === \"#!\") {\n\t\tcontent = \"//\"+content ;\n\t}\n\treturn content;\n}\n\nfunction btoa(str) {\n\tvar buffer ;\n\tif (str instanceof Buffer) {\n\t\tbuffer = str;\n\t} else {\n\t\tbuffer = new Buffer(str.toString(), 'binary');\n\t}\n\n\treturn buffer.toString('base64');\n}\n\nfunction compileNodentedFile(nodent,log) {\n    log = log || nodent.log ;\n\treturn function(mod, filename, parseOpts) {\n\t\tvar content = stripBOM(fs.readFileSync(filename, 'utf8'));\n\t\tvar pr = nodent.parse(content,filename,parseOpts);\n\t\tparseOpts = parseOpts || parseCompilerOptions(pr.ast,log, filename) ;\n\t\tnodent.asynchronize(pr,undefined,parseOpts,log) ;\n\t\tnodent.prettyPrint(pr,parseOpts) ;\n\t\tmod._compile(pr.code, pr.filename);\n\t}\n};\n\n// Things that DON'T depend on initOpts (or config, and therefore nodent)\nfunction asyncify(promiseProvider) {\n\tpromiseProvider = promiseProvider || Thenable ;\n\treturn function(obj,filter,suffix) {\n\t\tif (Array.isArray(filter)) {\n\t\t\tvar names = filter ;\n\t\t\tfilter = function(k,o) {\n\t\t\t\treturn names.indexOf(k)>=0 ;\n\t\t\t}\n\t\t} else {\n\t\t\tfilter = filter || function(k,o) {\n\t\t\t\treturn (!k.match(/Sync$/) || !(k.replace(/Sync$/,\"\") in o)) ;\n\t\t\t};\n\t\t}\n\n\t\tif (!suffix)\n\t\t\tsuffix = \"\" ;\n\n\t\tvar o = Object.create(obj) ;\n\t\tfor (var j in o) (function(){\n\t\t\tvar k = j ;\n\t\t\ttry {\n\t\t\t\tif (typeof obj[k]==='function' && (!o[k+suffix] || !o[k+suffix].isAsync) && filter(k,o)) {\n\t\t\t\t\to[k+suffix] = function() {\n\t\t\t\t\t\tvar a = Array.prototype.slice.call(arguments) ;\n\t\t\t\t\t\tvar resolver = function($return,$error) {\n\t\t\t\t\t\t\tvar cb = function(err,ok){\n\t\t\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\t\t\treturn $error(err) ;\n\t\t\t\t\t\t\t\tswitch (arguments.length) {\n\t\t\t\t\t\t\t\tcase 0: return $return() ;\n\t\t\t\t\t\t\t\tcase 2: return $return(ok) ;\n\t\t\t\t\t\t\t\tdefault: return $return(Array.prototype.slice.call(arguments,1)) ;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\t\t// If more args were supplied than declared, push the CB\n\t\t\t\t\t\t\tif (a.length > obj[k].length) {\n\t\t\t\t\t\t\t\ta.push(cb) ;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Assume the CB is the final arg\n\t\t\t\t\t\t\t\ta[obj[k].length-1] = cb ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar ret = obj[k].apply(obj,a) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t\treturn new promiseProvider(resolver) ;\n\t\t\t\t\t}\n\t\t\t\t\to[k+suffix].isAsync = true ;\n\t\t\t\t}\n\t\t\t} catch (ex) {\n\t\t\t\t// Log the fact that we couldn't augment this member??\n\t\t\t}\n\t\t})() ;\n\t\to[\"super\"] = obj ;\n\t\treturn o ;\n\t}\n};\n\nfunction prettyPrint(pr,opts) {\n\tvar map ;\n\tvar filepath = pr.filename.split(\"/\") ;\n\tvar filename = filepath.pop() ;\n\n\tvar out = outputCode(pr.ast,(opts && opts.sourcemap)?{map:{\n\t\tstartLine: opts.mapStartLine || 0,\n\t\tfile: filename+\"(original)\",\n\t\tsourceMapRoot: filepath.join(\"/\"),\n\t\tsourceContent: pr.origCode\n\t}}:null, pr.origCode) ;\n\n\tif (opts && opts.sourcemap){\n\t    try {\n\t        var mapUrl = \"\" ;\n\t        var jsmap = out.map.toJSON();\n\t        if (jsmap) {\n\t            // require an expression to defeat browserify\n\t            var SourceMapConsumer = require('source-map').SourceMapConsumer;\n\t            pr.sourcemap = jsmap ;\n\t            smCache[pr.filename] = {map:jsmap,smc:new SourceMapConsumer(jsmap)} ;\n\t            mapUrl = \"\\n\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,\"\n\t                +btoa(JSON.stringify(jsmap))+\"\\n\" ;\n\t        }\n\t        pr.code = out.code+mapUrl ;\n\t    } catch (ex) {\n\t        pr.code = out ;\n\t    }\n\t} else {\n        pr.code = out ;\n\t}\n\treturn pr ;\n}\n\nfunction parseCode(code,origFilename,__sourceMapping,opts) {\n\tif (typeof __sourceMapping===\"object\" && opts===undefined)\n\t\topts = __sourceMapping ;\n\n\tvar r = { origCode:code.toString(), filename:origFilename } ;\n\ttry {\n\t\tr.ast = parser.parse(r.origCode, opts && opts.parser) ;\n\t\tif (opts.babelTree) {\n\t\t\tparser.treeWalker(r.ast,function(node,descend,path){\n\t\t\t\tif (node.type==='Literal')\n\t\t\t\t\tpath[0].replace(treeSurgeon.babelLiteralNode(node.value)) ;\n\t\t\t\telse if (node.type==='Property') {\n\t\t\t\t    // Class/ObjectProperty in babel6\n\t\t\t\t    if (path[0].parent.type==='ClassBody'){\n\t\t\t\t        // There's no easy mapping here as it appears to be borderline in the specification?\n\t\t\t\t        // It's definitely a kind of ClassProperty tho....\n                        node.type = 'ClassProperty' ;\n\t\t\t\t    } else {\n\t\t\t\t        node.type = 'ObjectProperty' ;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tdescend() ;\n\t\t\t}) ;\n\t\t}\n\t\treturn r ;\n\t} catch (ex) {\n\t\tif (ex instanceof SyntaxError) {\n\t\t\tvar l = r.origCode.substr(ex.pos-ex.loc.column) ;\n\t\t\tl = l.split(\"\\n\")[0] ;\n\t\t\tex.message += \" \"+origFilename+\" (nodent)\\n\"+l+\"\\n\"+l.replace(/[\\S ]/g,\"-\").substring(0,ex.loc.column)+\"^\" ;\n\t\t\tex.stack = \"\" ;\n\t\t}\n\t\tthrow ex ;\n\t}\n}\n\n/* NodentCompiler prototypes, that refer to 'this' */\nfunction requireCover(cover,opts) {\n\topts = opts || {} ;\n\tvar key = cover+'|'+Object.keys(opts).sort().reduce(function(a,k){ return a+k+JSON.stringify(opts[k])},\"\") ;\n\tif (!this.covers[key]) {\n\t\tif (cover.indexOf(\"/\")>=0)\n\t\t\tthis.covers[key] = require(cover) ;\n\t\telse\n\t\t\tthis.covers[key] = require(__dirname+\"/covers/\"+cover);\n\t}\n\treturn this.covers[key](this,opts) ;\n}\n\nfunction compile(code,origFilename,__sourceMapping,opts) {\n\tif (typeof __sourceMapping===\"object\" && opts===undefined)\n\t\topts = __sourceMapping ;\n\n\topts = opts || {} ;\n\n\t// Fill in any default codeGen options\n\tfor (var k in defaultCodeGenOpts) {\n\t\tif (!(k in opts))\n\t\t\topts[k] = defaultCodeGenOpts[k] ;\n\t}\n\n\tvar pr = this.parse(code,origFilename,null,opts);\n\tthis.asynchronize(pr,null,opts,this.log || noLogger) ;\n\tthis.prettyPrint(pr,opts) ;\n\treturn pr ;\n}\n\nfunction generateRequestHandler(path, matchRegex, options) {\n\tvar cache = {} ;\n\tvar compiler = this ;\n\n\tif (!matchRegex)\n\t\tmatchRegex = /\\.njs$/ ;\n\tif (!options)\n\t\toptions = {compiler:{}} ;\n\telse if (!options.compiler)\n\t\toptions.compiler = {} ;\n\tvar compilerOptions = copyObj([initialCodeGenOpts,options.compiler]) ;\n\n\treturn function (req, res, next) {\n\t\tif (cache[req.url]) {\n\t\t\tres.setHeader(\"Content-Type\", cache[req.url].contentType);\n\t\t\toptions.setHeaders && options.setHeaders(res) ;\n\t\t\tres.write(cache[req.url].output) ;\n\t\t\tres.end();\n\t\t\treturn ;\n\t\t}\n\n\t\tif (!req.url.match(matchRegex) && !(options.htmlScriptRegex && req.url.match(options.htmlScriptRegex))) {\n\t\t\treturn next && next() ;\n\t\t}\n\n\t\tfunction sendException(ex) {\n\t\t\tres.statusCode = 500 ;\n\t\t\tres.write(ex.toString()) ;\n\t\t\tres.end() ;\n\t\t}\n\n\t\tvar filename = path+req.url ;\n\t\tif (options.extensions && !fs.existsSync(filename)) {\n\t\t\tfor (var i=0; i<options.extensions.length; i++) {\n\t\t\t\tif (fs.existsSync(filename+\".\"+options.extensions[i])) {\n\t\t\t\t\tfilename = filename+\".\"+options.extensions[i] ;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfs.readFile(filename,function(err,content){\n\t\t\tif (err) {\n\t\t\t\treturn sendException(err) ;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tvar pr,contentType ;\n\t\t\t\t\tif (options.htmlScriptRegex && req.url.match(options.htmlScriptRegex)) {\n\t\t\t\t\t\tpr = require('./htmlScriptParser')(compiler,content.toString(),req.url,options) ;\n\t\t\t\t\t\tcontentType = \"text/html\" ;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (options.runtime) {\n\t\t\t\t\t\t\tpr = \"Function.prototype.\"+compilerOptions.$asyncbind+\" = \"+$asyncbind.toString()+\";\" ;\n\t\t\t\t\t\t\tif (compilerOptions.generators)\n\t\t\t\t\t\t\t\tpr += \"Function.prototype.\"+compilerOptions.$asyncspawn+\" = \"+$asyncspawn.toString()+\";\" ;\n\t\t\t\t\t\t\tif (compilerOptions.wrapAwait && !compilerOptions.promises)\n\t\t\t\t\t\t\t\tpr += \"Object.\"+compilerOptions.$makeThenable+\" = \"+Thenable.resolve.toString()+\";\" ;\n\t\t\t\t\t\t\tcompilerOptions.mapStartLine = pr.split(\"\\n\").length ;\n\t\t\t\t\t\t\tpr += \"\\n\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpr = \"\" ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpr += compiler.compile(content.toString(),req.url,null,compilerOptions).code;\n\t\t\t\t\t\tcontentType = \"application/javascript\" ;\n\t\t\t\t\t}\n\t\t\t\t\tres.setHeader(\"Content-Type\", contentType);\n\t\t\t\t\tif (options.enableCache)\n\t\t\t\t\t\tcache[req.url] = {output:pr,contentType:contentType} ;\n\t\t\t\t\toptions.setHeaders && options.setHeaders(res) ;\n\t\t\t\t\tres.write(pr) ;\n\t\t\t\t\tres.end();\n\t\t\t\t} catch (ex) {\n\t\t\t\t\treturn sendException(ex) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}) ;\n\t};\n};\n\nfunction NodentCompiler(members) {\n\tthis.covers = {} ;\n\tthis._ident = NodentCompiler.prototype.version+\"_\"+Math.random() ;\n\tthis.setOptions(members) ;\n}\n\nNodentCompiler.prototype.setOptions = function(members){\n\tthis.log = members.log===false?noLogger:members.log||this.log;\n\tthis.options = copyObj([this.options,members]) ;\n\tdelete this.options.log ;\n\treturn this ;\n};\n\n$asyncbind.call($asyncbind) ;\n\nNodentCompiler.prototype.version =  require(\"./package.json\").version ;\nNodentCompiler.prototype.Thenable = Thenable ;\nNodentCompiler.prototype.EagerThenable = $asyncbind.EagerThenableFactory ;\nNodentCompiler.prototype.isThenable = function(x) { return x && x instanceof Object && typeof x.then===\"function\"} ;\nNodentCompiler.prototype.asyncify =  asyncify ;\nNodentCompiler.prototype.require =  requireCover ;\nNodentCompiler.prototype.generateRequestHandler = generateRequestHandler ;\n// Exported so they can be transported to a client\nNodentCompiler.prototype.$asyncspawn =  $asyncspawn ;\nNodentCompiler.prototype.$asyncbind =  $asyncbind ;\n// Exported ; but not to be used lightly!\nNodentCompiler.prototype.parse = parseCode ;\nNodentCompiler.prototype.compile =  compile ;\nNodentCompiler.prototype.asynchronize =  treeSurgeon.asynchronize ;\nNodentCompiler.prototype.prettyPrint =  prettyPrint ;\nNodentCompiler.prototype.parseCompilerOptions =  parseCompilerOptions ;\nNodentCompiler.prototype.getDefaultCompileOptions = undefined ;\n\nObject.defineProperty(NodentCompiler.prototype,\"Promise\",{\n\tget:function (){\n\t\tinitOpts.log(\"Warning: nodent.Promise is deprecated. Use nodent.Thenable instead\");\n\t\treturn Thenable;\n\t},\n\tenumerable:false,\n\tconfigurable:false\n}) ;\n\nfunction prepareMappedStackTrace(error, stack) {\n\tfunction mappedTrace(frame) {\n\t\tvar source = frame.getFileName();\n\t\tif (source && smCache[source]) {\n\t\t\tvar position = smCache[source].smc.originalPositionFor({\n\t\t\t\tline: frame.getLineNumber(),\n\t\t\t\tcolumn: frame.getColumnNumber()\n\t\t\t});\n\t\t\tif (position && position.line) {\n\t\t\t\tvar desc = frame.toString() ;\n\t\t\t\treturn '\\n    at '\n\t\t\t\t\t+ desc.substring(0,desc.length-1)\n\t\t\t\t\t+ \" => \\u2026\"+position.source+\":\"+position.line+\":\"+position.column\n\t\t\t\t\t+ (frame.getFunctionName()?\")\":\"\");\n\t\t\t}\n\t\t}\n\t\treturn '\\n    at '+frame;\n\t}\n\treturn error + stack.map(mappedTrace).join('');\n}\n\n// Set the 'global' references to the (backward-compatible) versions\n// required by the current version of Nodent\nfunction setGlobalEnvironment(initOpts) {\n\tvar codeGenOpts = defaultCodeGenOpts ;\n\t/*\n\tObject.$makeThenable\n\tObject.prototype.isThenable\n\tObject.prototype.asyncify\n\tFunction.prototype.noDentify // Moved to a cover as of v3.0.0\n\tFunction.prototype.$asyncspawn\n\tFunction.prototype.$asyncbind\n\tError.prepareStackTrace\n\tglobal[defaultCodeGenOpts.$error]\n\t*/\n\n\tvar augmentFunction = {} ;\n\taugmentFunction[defaultCodeGenOpts.$asyncbind] = {\n\t\tvalue:$asyncbind,\n\t\twritable:true,\n\t\tenumerable:false,\n\t\tconfigurable:true\n\t};\n\taugmentFunction[defaultCodeGenOpts.$asyncspawn] = {\n\t\tvalue:$asyncspawn,\n\t\twritable:true,\n\t\tenumerable:false,\n\t\tconfigurable:true\n\t};\n\ttry {\n\t    Object.defineProperties(Function.prototype,augmentFunction) ;\n\t} catch (ex) {\n\t    initOpts.log(\"Function prototypes already assigned: \",ex.messsage) ;\n\t}\n\n\t/**\n\t * We need a global to handle funcbacks for which no error handler has ever been defined.\n\t */\n\tif (!(defaultCodeGenOpts[defaultCodeGenOpts.$error] in global)) {\n\t\tglobal[defaultCodeGenOpts[defaultCodeGenOpts.$error]] = globalErrorHandler ;\n\t}\n\n\t// \"Global\" options:\n\t// If anyone wants to augment Object, do it. The augmentation does not depend on the config options\n\tif (initOpts.augmentObject) {\n\t\tObject.defineProperties(Object.prototype,{\n\t\t\t\"asyncify\":{\n\t\t\t\tvalue:function(promiseProvider,filter,suffix){\n\t\t\t\t\treturn asyncify(promiseProvider)(this,filter,suffix)\n\t\t\t\t},\n\t\t\t\twritable:true,\n\t\t\t\tconfigurable:true\n\t\t\t},\n\t\t\t\"isThenable\":{\n\t\t\t\tvalue:function(){ return Thenable.isThenable(this) },\n\t\t\t\twritable:true,\n\t\t\t\tconfigurable:true\n\t\t\t}\n\t\t}) ;\n\t}\n\n\tObject[defaultCodeGenOpts.$makeThenable] = Thenable.resolve ;\n}\n\n/* Construct a 'nodent' object - combining logic and options */\nvar compiler ;\nfunction initialize(initOpts){\n\t// Validate the options\n/* initOpts:{\n * \t\tlog:function(msg),\n * \t\taugmentObject:boolean,\n * \t\textension:string?\n * \t\tdontMapStackTraces:boolean\n */\n\tif (!initOpts)\n\t\tinitOpts = {} ;\n\telse {\n\t\t// Throw an error for any options we don't know about\n\t\tfor (var k in initOpts) {\n\t\t\tif (k===\"use\")\n\t\t\t\tcontinue ; // deprecated\n\t\t\tif (!config.hasOwnProperty(k))\n\t\t\t\tthrow new Error(\"NoDent: unknown option: \"+k+\"=\"+JSON.stringify(initOpts[k])) ;\n\t\t}\n\t}\n\n\n\tif (compiler) {\n\t\tcompiler.setOptions(initOpts);\n\t} else {\n\t\t// Fill in any missing options with their default values\n\t\tObject.keys(config).forEach(function(k){\n\t\t\tif (!(k in initOpts))\n\t\t\t\tinitOpts[k] = config[k] ;\n\t\t}) ;\n\t\tcompiler = new NodentCompiler(initOpts) ;\n\t}\n\n\t// If anyone wants to mapStackTraces, do it. The augmentation does not depend on the config options\n\tif (!initOpts.dontMapStackTraces) {\n\t\t// This function is part of the V8 stack trace API, for more info see:\n\t\t// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\tError.prepareStackTrace = prepareMappedStackTrace ;\n\t}\n\n\tsetGlobalEnvironment(initOpts) ;\n\n\t/* If we've not done it before, create a compiler for '.js' scripts */\n\t// Create a new compiler\n\n\tvar nodentLoaders = [];\n\tfunction compareSemVer(a,b) {\n\t\ta = a.split('.') ;\n\t\tb = b.split('.') ;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tif (a[i]<b[i]) return -1 ;\n\t\t\tif (a[i]>b[i]) return 1 ;\n\t\t}\n\t\treturn 0 ;\n\t}\n\n    function versionAwareNodentJSLoader(mod,filename) {\n        if (filename.match(/nodent\\/nodent\\.js$/)) {\n            var downLevel = {path:filename.replace(/\\/node_modules\\/nodent\\/nodent\\.js$/,\"\")} ;\n            if (downLevel.path) {\n                downLevel.version = JSON.parse(fs.readFileSync(filename.replace(/nodent\\.js$/,\"package.json\"))).version ;\n                // Load the specified nodent\n                stdJSLoader(mod,filename) ;\n\n                // If the version of nodent we've just loaded is lower than the\n                // current (version-aware) version, hook the initialzer\n                // so we can replace the JS loader after it's been run.\n                if (compareSemVer(downLevel.version,NodentCompiler.prototype.version)<0) {\n                    downLevel.originalNodentLoader = mod.exports ;\n                    mod.exports = function(){\n                        var previousJSLoader = require.extensions['.js'] ;\n                        var defaultNodentInstance = downLevel.originalNodentLoader.apply(this,arguments) ;\n                        downLevel.jsCompiler = require.extensions['.js'] ;\n                        require.extensions['.js'] = previousJSLoader ;\n                        setGlobalEnvironment(initOpts) ;\n                        return defaultNodentInstance ;\n                    } ;\n                    Object.keys(downLevel.originalNodentLoader).forEach(function(k){\n                        mod.exports[k] = downLevel.originalNodentLoader[k] ;\n                    }) ;\n                    nodentLoaders.push(downLevel) ;\n                    nodentLoaders = nodentLoaders.sort(function(a,b){\n                        return b.path.length - a.path.length ;\n                    }) ;\n                }\n            }\n        } else if (filename.match(/node_modules\\/nodent\\/.*\\.js$/)) {\n            // Things inside nodent always use the standard loader\n            return stdJSLoader(mod,filename) ;\n        } else {\n            // The the appropriate loader for this file\n            for (var n=0; n<nodentLoaders.length; n++) {\n                if (filename.slice(0,nodentLoaders[n].path.length)==nodentLoaders[n].path) {\n                    //console.log(\"Using nodent@\",nodentLoaders[n].version,\"to load\",filename) ;\n                    if (!nodentLoaders[n].jsCompiler) {\n                        // The client app loaded, but never initialised nodent (so it can only\n                        // be using library/runtime functions, not the require-hook compiler)\n                        return stdJSLoader(mod,filename) ;\n                    } else {\n                        if (nodentLoaders[n].jsCompiler === versionAwareNodentJSLoader)\n                            break ;\n                        return nodentLoaders[n].jsCompiler.apply(this,arguments) ;\n                    }\n                }\n            }\n\n            var content = stripBOM(fs.readFileSync(filename, 'utf8'));\n            var parseOpts = parseCompilerOptions(content,initOpts.log,filename) ;\n            if (parseOpts) {\n                return stdCompiler(mod,filename,parseOpts) ;\n            }\n            return stdJSLoader(mod,filename) ;\n        }\n    }\n\n    function registerExtension(extension) {\n        if (Array.isArray(extension))\n            return extension.forEach(registerExtension) ;\n\n        if (require.extensions[extension]) {\n            var changedKeys = Object.keys(initOpts).filter(function(k){ return compiler[k] != initOpts[k]}) ;\n            if (changedKeys.length) {\n                initOpts.log(\"File extension \"+extension+\" already configured for async/await compilation.\") ;\n            }\n        }\n    \trequire.extensions[extension] = compileNodentedFile(compiler,initOpts.log) ;\n    }\n\n    if (!initOpts.dontInstallRequireHook) {\n\t\tif (!stdJSLoader) {\n\t\t\tstdJSLoader = require.extensions['.js'] ;\n\t\t\tvar stdCompiler = compileNodentedFile(compiler,initOpts.log) ;\n\t\t\trequire.extensions['.js'] = versionAwareNodentJSLoader ;\n\t\t}\n\n\t\t/* If the initOpts specified a file extension, use this compiler for it */\n\t\tif (initOpts.extension) {\n\t\t\tregisterExtension(initOpts.extension) ;\n\t\t}\n\t}\n\n\t// Finally, load any required covers\n\tif (initOpts.use) {\n\t\tif (Array.isArray(initOpts.use)) {\n\t\t\tinitOpts.log(\"Warning: nodent({use:[...]}) is deprecated. Use nodent.require(module,options)\\n\"+(new Error().stack).split(\"\\n\")[2]);\n\t\t\tif (initOpts.use.length) {\n\t\t\t\tinitOpts.use.forEach(function(x){\n\t\t\t\t\tcompiler[x] = compiler.require(x) ;\n\t\t\t\t}) ;\n\t\t\t}\n\t\t} else {\n\t\t\tinitOpts.log(\"Warning: nodent({use:{...}}) is deprecated. Use nodent.require(module,options)\\n\"+(new Error().stack).split(\"\\n\")[2]);\n\t\t\tObject.keys(initOpts.use).forEach(function(x){\n\t\t\t\tcompiler[x] = compiler.require(x,initOpts.use[x])\n\t\t\t}) ;\n\t\t}\n\t}\n\treturn compiler ;\n} ;\n\n/* Export these so that we have the opportunity to set the options for the default .js parser */\ninitialize.setDefaultCompileOptions = function(compiler,env) {\n\tif (compiler) {\n\t\tObject.keys(compiler).forEach(function(k){\n\t\t\tif (!(k in defaultCodeGenOpts))\n\t\t\t\tthrow new Error(\"NoDent: unknown compiler option: \"+k) ;\n\t\t\tdefaultCodeGenOpts[k] = compiler[k] ;\n\t\t}) ;\n\t}\n\n\tenv && Object.keys(env).forEach(function(k){\n\t\tif (!(k in env))\n\t\t\tthrow new Error(\"NoDent: unknown configuration option: \"+k) ;\n\t\tconfig[k] = env[k] ;\n\t}) ;\n\treturn initialize ;\n};\n\ninitialize.setCompileOptions = function(set,compiler) {\n\toptionSet[set] = optionSet[set] || copyObj([defaultCodeGenOpts]);\n\tcompiler && Object.keys(compiler).forEach(function(k){\n\t\tif (!(k in defaultCodeGenOpts))\n\t\t\tthrow new Error(\"NoDent: unknown compiler option: \"+k) ;\n\t\toptionSet[set][k] = compiler[k] ;\n\t}) ;\n\treturn initialize ;\n};\n\ninitialize.asyncify = asyncify ;\ninitialize.Thenable = $asyncbind.Thenable ;\ninitialize.EagerThenable = $asyncbind.EagerThenableFactory ;\n\nmodule.exports = initialize ;\n\nfunction runFromCLI(){\n    function readStream(stream) {\n        return new Thenable(function ($return, $error) {\n            var buffer = [] ;\n            stream.on('data',function(data){\n                buffer.push(data)\n            }) ;\n            stream.on('end',function(){\n                var code = buffer.map(function(b){ return b.toString()}).join(\"\") ;\n                return $return(code);\n            }) ;\n            stream.on('error',$error) ;\n        }.$asyncbind(this));\n    }\n\n    function getCLIOpts(start) {\n        var o = [] ;\n        for (var i=start || 2; i<process.argv.length; i++) {\n            if (process.argv[i].slice(0,2)==='--') {\n                var opt = process.argv[i].slice(2).split('=') ;\n                o[opt[0]] = opt[1] || true ;\n            }\n            else\n                o.push(process.argv[i]) ;\n        }\n        return o ;\n    }\n\n    function processInput(content,name){\n        try {\n            var pr ;\n            var parseOpts ;\n\n            // Input options\n            if (cli.fromast) {\n                content = JSON.parse(content) ;\n                pr = { origCode:\"\", filename:filename, ast: content } ;\n                parseOpts = parseCompilerOptions(content,nodent.log) ;\n                if (!parseOpts) {\n                    var directive = cli.use ? '\"use nodent-'+cli.use+'\";' : '\"use nodent\";' ;\n                    parseOpts = parseCompilerOptions(directive,nodent.log) ;\n                    console.warn(\"/* \"+filename+\": No 'use nodent*' directive, assumed \"+directive+\" */\") ;\n                }\n            } else {\n                parseOpts = parseCompilerOptions(cli.use?'\"use nodent-'+cli.use+'\";':content,nodent.log) ;\n                if (!parseOpts) {\n                    parseOpts = parseCompilerOptions('\"use nodent\";',nodent.log) ;\n                    if (!cli.dest)\n                        console.warn(\"/* \"+filename+\": 'use nodent*' directive missing/ignored, assumed 'use nodent;' */\") ;\n                }\n                pr = nodent.parse(content,filename,parseOpts);\n            }\n\n            // Processing options\n            if (!cli.parseast && !cli.pretty)\n                nodent.asynchronize(pr,undefined,parseOpts,nodent.log) ;\n\n            // Output options\n            nodent.prettyPrint(pr,parseOpts) ;\n            if (cli.out || cli.pretty || cli.dest) {\n                if (cli.dest && !name)\n                    throw new Error(\"Can't write unknown file to \"+cli.dest) ;\n\n                var output = \"\" ;\n                if (cli.runtime) {\n                    output += (\"Function.prototype.$asyncbind = \"+Function.prototype.$asyncbind.toString()+\";\\n\") ;\n                    output += (\"global.$error = global.$error || \"+global.$error.toString()+\";\\n\") ;\n                }\n                output += pr.code ;\n                if (name && cli.dest) {\n                    fs.writeFileSync(cli.dest+name,output) ;\n                    console.log(\"Compiled\",cli.dest+name) ;\n                } else {\n                    console.log(output);\n                }\n            }\n            if (cli.minast || cli.parseast) {\n                console.log(JSON.stringify(pr.ast,function(key,value){\n                    return key[0]===\"$\" || key.match(/^(start|end|loc)$/)?undefined:value\n                },2,null)) ;\n            }\n            if (cli.ast) {\n                console.log(JSON.stringify(pr.ast,function(key,value){ return key[0]===\"$\"?undefined:value},0)) ;\n            }\n            if (cli.exec) {\n                (new Function(pr.code))() ;\n            }\n        } catch (ex) {\n            console.error(ex) ;\n        }\n    }\n\n\tvar path = require('path') ;\n\tvar initOpts = (process.env.NODENT_OPTS && JSON.parse(process.env.NODENT_OPTS)) || {};\n\tvar filename, cli = getCLIOpts() ;\n\tinitialize.setDefaultCompileOptions({\n\t\tsourcemap:cli.sourcemap,\n        wrapAwait:cli.wrapAwait,\n        lazyThenables:cli.lazyThenables,\n        noRuntime:cli.noruntime,\n        es6target:cli.es6target,\n        parser:cli.noextensions?{noNodentExtensions:true}:undefined\n\t});\n\n\tvar nodent = initialize({\n\t\taugmentObject:true\n\t}) ;\n\n\tif (!cli.fromast && !cli.parseast && !cli.pretty && !cli.out && !cli.dest && !cli.ast && !cli.minast && !cli.exec) {\n\t\t// No input/output options - just require the\n\t\t// specified module now we've initialized nodent\n\t\ttry {\n\t\t\tvar mod = path.resolve(cli[0]) ;\n\t\t\treturn require(mod);\n\t\t} catch (ex) {\n\t\t\tex && (ex.message = cli[0]+\": \"+ex.message) ;\n\t\t\tthrow ex ;\n\t\t}\n\t}\n\n\tif (cli.length==0 || cli[0]==='-') {\n\t\tfilename = \"(stdin)\" ;\n\t\treturn readStream(process.stdin).then(processInput,globalErrorHandler) ;\n\t} else {\n\t    for (var i=0; i<cli.length; i++) {\n    \t\tfilename = path.resolve(cli[i]) ;\n    \t\tprocessInput(stripBOM(fs.readFileSync(filename, 'utf8')),cli[i]) ;\n\t    }\n\t    return ;\n\t}\n}\n\nif (require.main===module && process.argv.length>=3)\n    runFromCLI() ;\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/lib/output.js":"'use strict';\n\n// This module is derived from Astring by David Bonnet (see below), but heavily\n// modified to support source-maps & es7 as specified in\n// https://github.com/estree/estree/blob/master/experimental/async-functions.md\n// --------------------\n// Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.\n//\n// Astring was written by David Bonnet and released under an MIT license.\n//\n// The Git repository for Astring is available at:\n// https://github.com/davidbonnet/astring.git\n//\n// Please use the GitHub bug tracker to report issues:\n// https://github.com/davidbonnet/astring/issues\n\nvar SourceMapGenerator = require('source-map').SourceMapGenerator;\nvar ForInStatement, RestElement, BinaryExpression, ArrayExpression, BlockStatement;\n\nvar repeat ;\nif (\"\".repeat) {\n    repeat = function(str,count){\n        return count && str ? str.repeat(count):\"\" ;\n    } ;\n} else {\n    var cache = {} ;\n    repeat = function(str,count) {\n        if (!count || !str) return \"\" ;\n        var k = \"\"+str+count ;\n        if (!cache[k]) {\n            var out = [];\n            while (count--) {\n                out.push(str);\n            }\n            cache[k] = out.join('');\n        }\n        return cache[k] ;\n    }\n}\n\nvar OPERATORS_PRECEDENCE = {\n    'ExpressionStatement': -1, //  Use to parenthesize FunctionExpressions as statements\n    'Identifier': 21,\n    'Literal': 21,\n\t'BooleanLiteral':21,\n\t'RegExpLiteral':21,\n\t'NumericLiteral':21,\n\t'StringLiteral':21,\n\t'NullLiteral':21,\n    'ThisExpression': 21,\n    'SuperExpression': 21,\n    'ObjectExpression': 21,\n    'ClassExpression': 21,\n    //\t\t'(_)':20,\t// Parens\n    'MemberExpression': 19,\n    //\t\t'new()':19,\n    'CallExpression': 18,\n    'NewExpression': 18,\n    'ArrayExpression': 17.5,\n    'FunctionExpression': 17.5,\n    'FunctionDeclaration': 17.5,\n    'ArrowFunctionExpression': 17.5,\n    'UpdateExpression++': 17, //  Postfix is 17, prefix is 16\n    'UpdateExpression--': 17, //  Postfix is 17, prefix is 16\n    'UpdateExpression++prefix': 16, //  Postfix is 17, prefix is 16\n    'UpdateExpression--prefix': 16, //  Postfix is 17, prefix is 16\n    'UnaryExpression':16, // ! ~ + - typeof void delete\n    'AwaitExpression': 16,\n    'BinaryExpression**': 15,\n    'BinaryExpression*': 15,\n    'BinaryExpression/': 15,\n    'BinaryExpression%': 15,\n    'BinaryExpression+': 14,\n    'BinaryExpression-': 14,\n    'BinaryExpression<<': 13,\n    'BinaryExpression>>': 13,\n    'BinaryExpression>>>': 13,\n    'BinaryExpression<': 12,\n    'BinaryExpression<=': 12,\n    'BinaryExpression>': 12,\n    'BinaryExpression>=': 12,\n    'BinaryExpressionin': 12,\n    'BinaryExpressioninstanceof': 12,\n    'BinaryExpression==': 11,\n    'BinaryExpression===': 11,\n    'BinaryExpression!=': 11,\n    'BinaryExpression!==': 11,\n    'BinaryExpression&': 10,\n    'BinaryExpression^': 9,\n    'BinaryExpression|': 8,\n    'LogicalExpression&&': 7,\n    'LogicalExpression||': 6,\n    'ConditionalExpression': 5,\n    'AssignmentPattern': 4,\n    'AssignmentExpression': 4,\n    'yield': 3,\n    'YieldExpression': 3,\n    'SpreadElement': 2,\n    'comma-separated-list':1.5,\n    'SequenceExpression': 1\n};\n\nvar CommaList = {type:'comma-separated-list'} ;\n\nfunction precedence(node) {\n    var p = OPERATORS_PRECEDENCE[node.type] || OPERATORS_PRECEDENCE[node.type+node.operator]  || OPERATORS_PRECEDENCE[node.type+node.operator+(node.prefix?\"prefix\":\"\")];\n    if (p !== undefined)\n        return p;\n    //console.log(\"Precedence?\",node.type,node.operator) ;\n    return 20;\n}\n\nfunction out(node,state,type) {\n    var f = this[type || node.type] ;\n    if (f) {\n/*\n        try {\n            var attr = Object.keys(node).filter(k=>k[0]==='$').map(k=>k+(node[k]?\"+\":\"-\")) ;\n            if (attr.length) \n                state.write(node,\"/*\"+attr.join(\", \")+\"\\u002A/ \") ;\n        } catch (ex) {} ;\n*/        \n        f.call(this, node, state);\n    } else {\n        // Unknown node type - just spew its source\n        state.write(node,\"/*\"+node.type+\"?*/ \"+state.sourceAt(node.start,node.end)) ;\n    }\n}\nfunction expr(state, parent, node, assoc) {\n    if (assoc===2 ||\n            precedence(node) < precedence(parent) ||\n            (precedence(node) == precedence(parent) && (assoc || parent.right === node))) {\n        state.write(null, '(');\n        this.out(node, state,node.type);\n        state.write(null, ')');\n    } else {\n        this.out(node, state,node.type);\n    }\n}\nfunction formatParameters(params, state) {\n    var param;\n    state.write(null, '(');\n    if (params != null && params.length > 0) {\n        this.out(params[0], state,params[0].type);\n        for (var i = 1, length = params.length; i < length; i++) {\n            param = params[i];\n            state.write(param, ', ');\n            this.out(param, state,param.type);\n        }\n    }\n    state.write(null, ') ');\n}\nvar traveler = {\n\tout: out,\n    expr: expr,\n    formatParameters: formatParameters,\n    Program: function (node, state) {\n        var statements, statement;\n        var indent = repeat(state.indent, state.indentLevel);\n        var lineEnd = state.lineEnd;\n        statements = node.body;\n        for (var i = 0, length = statements.length; i < length; i++) {\n            statement = statements[i];\n            state.write(null, indent);\n            this.out(statement, state,statement.type);\n            state.write(null, lineEnd);\n        }\n    },\n    BlockStatement: BlockStatement = function (node, state) {\n        var statements, statement;\n        var indent = repeat(state.indent, state.indentLevel++);\n        var lineEnd = state.lineEnd;\n        var statementIndent = indent + state.indent;\n        state.write(node, '{');\n        statements = node.body;\n        if (statements != null && statements.length > 0) {\n            state.write(null, lineEnd);\n            for (var i = 0, length = statements.length; i < length; i++) {\n                statement = statements[i];\n                state.write(null, statementIndent);\n                this.out(statement, state,statement.type);\n                state.write(null, lineEnd);\n            }\n            state.write(null, indent);\n        }\n        state.write(node.loc ? {\n            loc: {\n                start: {\n                    line: node.loc.end.line,\n                    column: 0\n                }\n            }\n        } : null, '}');\n        state.indentLevel--;\n    },\n    ClassBody: BlockStatement,\n    EmptyStatement: function (node, state) {\n        state.write(node, ';');\n    },\n    ParenthesizedExpression: function (node, state) {\n        this.expr(state, node, node.expression, 2);\n    },\n    ExpressionStatement: function (node, state) {\n        if (node.expression.type === 'FunctionExpression' || node.expression.type === 'ObjectExpression') {\n            state.write(null, '(');\n            this.expr(state, node, node.expression);\n            state.write(null, ')');\n        } else {\n            this.expr(state, node, node.expression);\n        }\n        state.write(null, ';');\n    },\n    IfStatement: function (node, state) {\n        state.write(node, 'if (');\n        this.out(node.test, state,node.test.type);\n        state.write(null, ') ');\n        if (node.consequent.type !== 'BlockStatement')\n            state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel + 1));\n        this.out(node.consequent, state,node.consequent.type);\n        if (node.alternate != null) {\n            if (node.consequent.type !== 'BlockStatement')\n                state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel));\n            state.write(null, ' else ');\n            if (node.alternate.type !== 'BlockStatement' && node.alternate.type !== 'IfStatement')\n                state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel + 1));\n            this.out(node.alternate, state,node.alternate.type);\n        }\n    },\n    LabeledStatement: function (node, state) {\n        this.out(node.label, state,node.label.type);\n        state.write(null, ':');\n        this.out(node.body, state,node.body.type);\n    },\n    BreakStatement: function (node, state) {\n        state.write(node, 'break');\n        if (node.label) {\n            state.write(null, ' ');\n            this.out(node.label, state,node.label.type);\n        }\n        state.write(null, ';');\n    },\n    ContinueStatement: function (node, state) {\n        state.write(node, 'continue');\n        if (node.label) {\n            state.write(null, ' ');\n            this.out(node.label, state,node.label.type);\n        }\n        state.write(null, ';');\n    },\n    WithStatement: function (node, state) {\n        state.write(node, 'with (');\n        this.out(node.object, state,node.object.type);\n        state.write(null, ') ');\n        this.out(node.body, state,node.body.type);\n    },\n    SwitchStatement: function (node, state) {\n        var occurence, consequent, statement;\n        var indent = repeat(state.indent, state.indentLevel++);\n        var lineEnd = state.lineEnd;\n        state.indentLevel++;\n        var caseIndent = indent + state.indent;\n        var statementIndent = caseIndent + state.indent;\n        state.write(node, 'switch (');\n        this.out(node.discriminant, state,node.discriminant.type);\n        state.write(null, ') {', lineEnd);\n        var occurences = node.cases;\n        for (var i = 0; i < occurences.length; i++) {\n            occurence = occurences[i];\n            if (occurence.test) {\n                state.write(occurence, caseIndent, 'case ');\n                this.out(occurence.test, state,occurence.test.type);\n                state.write(null, ':', lineEnd);\n            } else {\n                state.write(occurence, caseIndent, 'default:', lineEnd);\n            }\n            consequent = occurence.consequent;\n            for (var j = 0; j < consequent.length; j++) {\n                statement = consequent[j];\n                state.write(null, statementIndent);\n                this.out(statement, state,statement.type);\n                state.write(null, lineEnd);\n            }\n        }\n        state.indentLevel -= 2;\n        state.write(null, indent, '}');\n    },\n    ReturnStatement: function (node, state) {\n        if (node.async)\n            state.write(node, ' async ');\n        state.write(node, 'return');\n        if (node.argument) {\n            state.write(null, ' ');\n            this.out(node.argument, state,node.argument.type);\n        }\n        state.write(null, ';');\n    },\n    ThrowStatement: function (node, state) {\n        if (node.async)\n            state.write(node, ' async ');\n        state.write(node, 'throw ');\n        this.out(node.argument, state,node.argument.type);\n        state.write(null, ';');\n    },\n    TryStatement: function (node, state) {\n        var handler;\n        state.write(node, 'try ');\n        this.out(node.block, state,node.block.type);\n        if (node.handler) {\n            this.out(node.handler, state, node.handler.type)\n        }\n        if (node.finalizer) {\n            state.write(node.finalizer, ' finally ');\n            this.out(node.finalizer, state,node.finalizer.type);\n        }\n    },\n    CatchClause: function (node, state) {\n        state.write(node, ' catch (');\n        this.out(node.param, state, node.param.type);\n        state.write(null, ') ');\n        this.out(node.body, state, node.body.type);\n    },\n    WhileStatement: function (node, state) {\n        state.write(node, 'while (');\n        this.out(node.test, state,node.test.type);\n        state.write(null, ') ');\n        if (node.body.type !== 'BlockStatement')\n            state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel + 1));\n        this.out(node.body, state,node.body.type);\n    },\n    DoWhileStatement: function (node, state) {\n        state.write(node, 'do ');\n        if (node.body.type !== 'BlockStatement')\n            state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel + 1));\n        this.out(node.body, state,node.body.type);\n        state.write(null, ' while (');\n        this.out(node.test, state,node.test.type);\n        state.write(null, ');');\n    },\n    ForStatement: function (node, state) {\n        state.write(node, 'for (');\n        if (node.init != null) {\n            var init = node.init, type = init.type;\n            state.inForInit++ ;\n            this.out(init, state,type);\n            state.inForInit-- ;\n            if (type !== 'VariableDeclaration')\n              state.write(null, '; ');\n        } else {\n          state.write(null, '; ');\n        }\n        if (node.test)\n            this.out(node.test, state,node.test.type);\n        state.write(null, '; ');\n        if (node.update)\n            this.out(node.update, state,node.update.type);\n        state.write(null, ') ');\n        if (node.body.type !== 'BlockStatement')\n            state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel + 1));\n        this.out(node.body, state,node.body.type);\n    },\n    ForInStatement: ForInStatement = function (node, state) {\n        state.write(node, 'for (');\n        var left = node.left, type = left.type;\n        state.inForInit++ ;\n        this.out(left, state,type);\n        if (type[0] === 'V' && type.length === 19) {\n            state.back();\n        }\n        state.inForInit-- ;\n        state.write(null, node.type[3] === 'I' ? ' in ' : ' of ');\n        this.out(node.right, state,node.right.type);\n        state.write(null, ') ');\n        if (node.body.type !== 'BlockStatement')\n            state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel + 1));\n        this.out(node.body, state,node.body.type);\n    },\n    ForOfStatement: ForInStatement,\n    DebuggerStatement: function (node, state) {\n        state.write(node, 'debugger;');\n    },\n    Function: function (node, state) {\n        if (node.async)\n            state.write(node, 'async ');\n        state.write(node, node.generator ? 'function* ' : 'function ');\n        if (node.id)\n            state.write(node.id, node.id.name);\n        this.formatParameters(node.params, state);\n        this.out(node.body, state,node.body.type);\n    },\n    FunctionDeclaration: function (node, state) {\n        this.Function(node, state);\n        state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel));\n    },\n    FunctionExpression: function (node, state) {\n        this.Function(node, state);\n    },\n    VariableDeclaration: function (node, state) {\n        var declarations = node.declarations;\n        state.write(node, node.kind, ' ');\n        var length = declarations.length;\n        if (length > 0) {\n            this.out(declarations[0], state,'VariableDeclarator');\n            for (var i = 1; i < length; i++) {\n                state.write(null, ', ');\n                this.out(declarations[i], state,'VariableDeclarator');\n            }\n        }\n        state.write(null, ';');\n    },\n    VariableDeclarator: function (node, state) {\n        this.out(node.id, state,node.id.type);\n        if (node.init != null) {\n            state.write(null, ' = ');\n            this.expr(state,CommaList,node.init) ;\n        }\n    },\n    ClassDeclaration: function (node, state) {\n        state.write(node, 'class ');\n        if (node.id) {\n            state.write(node.id, node.id.name + ' ');\n        }\n        if (node.superClass) {\n            state.write(null, 'extends ');\n            this.out(node.superClass, state,node.superClass.type);\n            state.write(null, ' ');\n        }\n        this.out(node.body, state,'BlockStatement');\n    },\n    ImportSpecifier: function (node, state) {\n        if (node.local.name == node.imported.name) {\n            this.out(node.local, state,node.local.type);\n        } else {\n            this.out(node.imported, state,node.imported.type);\n            state.write(null, ' as ');\n            this.out(node.local, state,node.local.type);\n        }\n    },\n    ImportDefaultSpecifier: function (node, state) {\n        this.out(node.local, state,node.local.type);\n    },\n    ImportNamespaceSpecifier: function (node, state) {\n        state.write(null, '* as ');\n        this.out(node.local, state,node.local.type);\n    },\n    ImportDeclaration: function (node, state) {\n        var i, specifier, name;\n        state.write(node, 'import ');\n        var specifiers = node.specifiers;\n        var length = specifiers.length;\n        var block = true;\n        if (length > 0) {\n            for (var i = 0; i < length; i++) {\n                if (specifiers[i].type === 'ImportSpecifier' && block) {\n                    block = false;\n                    state.write(null, '{');\n                }\n                this.out(specifiers[i], state,specifiers[i].type);\n                if (i < length - 1)\n                    state.write(null, ', ');\n            }\n            if (specifiers[length - 1].type === 'ImportSpecifier')\n                state.write(null, '}');\n            state.write(null, ' from ');\n        }\n        state.write(node.source, node.source.raw);\n        state.write(null, ';');\n    },\n    ExportDefaultDeclaration: function (node, state) {\n        state.write(node, 'export default ');\n        this.out(node.declaration, state,node.declaration.type);\n    },\n    ExportSpecifier: function (node, state) {\n        if (node.local.name == node.exported.name) {\n            this.out(node.local, state,node.local.type);\n        } else {\n            this.out(node.local, state,node.local.type);\n            state.write(null, ' as ');\n            this.out(node.exported, state,node.exported.type);\n        }\n    },\n    ExportNamedDeclaration: function (node, state) {\n        var specifier, name;\n        state.write(node, 'export ');\n        if (node.declaration) {\n            this.out(node.declaration, state,node.declaration.type);\n        } else {\n            var specifiers = node.specifiers;\n            state.write(node, '{');\n            if (specifiers && specifiers.length > 0) {\n                for (var i = 0; i < specifiers.length; i++) {\n                    this.out(specifiers[i], state,specifiers[i].type);\n                    if (i < specifiers.length - 1)\n                        state.write(null, ', ');\n                }\n            }\n            state.write(null, '}');\n            if (node.source) {\n                state.write(node.source, ' from ', node.source.raw);\n            }\n            state.write(null, ';');\n        }\n    },\n    ExportAllDeclaration: function (node, state) {\n        state.write(node, 'export * from ');\n        state.write(node.source, node.source.raw, ';');\n    },\n    MethodDefinition: function (node, state) {\n        if (node.value.async)\n            state.write(node, 'async ');\n        if (node.static)\n            state.write(node, 'static ');\n        switch (node.kind) {\n            case 'get':\n            case 'set':\n                state.write(node, node.kind, ' ');\n                break;\n            default:\n                break;\n        }\n        if (node.value.generator)\n          state.write(null, '*');\n        if (node.computed) {\n            state.write(null, '[');\n            this.out(node.key, state,node.key.type);\n            state.write(null, ']');\n        } else {\n            this.out(node.key, state,node.key.type);\n        }\n        this.formatParameters(node.value.params, state);\n        this.out(node.value.body, state,node.value.body.type);\n    },\n    ClassMethod: function (node,state){\n        if (node.async)\n            state.write(node, 'async ');\n        if (node.static)\n            state.write(node, 'static ');\n        switch (node.kind) {\n            case 'get':\n            case 'set':\n                state.write(node, node.kind, ' ');\n                break;\n            default:\n                break;\n        }\n        if (node.generator)\n          state.write(null, '*');\n        if (node.computed) {\n            state.write(null, '[');\n            this.out(node.key, state,node.key.type);\n            state.write(null, ']');\n        } else {\n            this.out(node.key, state,node.key.type);\n        }\n        this.formatParameters(node.params, state);\n        this.out(node.body, state, node.body.type);\n    },\n    ClassExpression: function (node, state) {\n        this.out(node, state,'ClassDeclaration');\n    },\n    ArrowFunctionExpression: function (node, state) {\n        if (node.async)\n            state.write(node, 'async ');\n        if (node.params.length===1 && node.params[0].type==='Identifier') {\n            this.out(node.params[0], state, node.params[0].type) ;\n            state.write(node, ' => ');\n        } else {\n            this.formatParameters(node.params, state);\n            state.write(node, '=> ');\n        }\n        if (node.body.type === 'ObjectExpression' || node.body.type === 'SequenceExpression') {\n            state.write(null, '(');\n            this.out(node.body, state,node.body.type);\n            state.write(null, ')');\n        } else {\n            this.out(node.body, state,node.body.type);\n        }\n    },\n    ThisExpression: function (node, state) {\n        state.write(node, 'this');\n    },\n    Super: function (node, state) {\n        state.write(node, 'super');\n    },\n    RestElement: RestElement = function (node, state) {\n        state.write(node, '...');\n        this.out(node.argument, state,node.argument.type);\n    },\n    SpreadElement: RestElement,\n    YieldExpression: function (node, state) {\n        state.write(node, node.delegate ? 'yield*' : 'yield');\n        if (node.argument) {\n            state.write(null, ' ');\n            this.expr(state, node, node.argument);\n        }\n    },\n    AwaitExpression: function (node, state) {\n        state.write(node, 'await ');\n        this.expr(state, node, node.argument);\n    },\n    TemplateLiteral: function (node, state) {\n        var expression;\n        var quasis = node.quasis, expressions = node.expressions;\n        state.write(node, '`');\n        for (var i = 0, length = expressions.length; i < length; i++) {\n            expression = expressions[i];\n            state.write(quasis[i].value, quasis[i].value.raw);\n            state.write(null, '${');\n            this.out(expression, state,expression.type);\n            state.write(null, '}');\n        }\n        state.write(quasis[quasis.length - 1].value, quasis[quasis.length - 1].value.raw);\n        state.write(node, '`');\n    },\n    TaggedTemplateExpression: function (node, state) {\n        this.out(node.tag, state,node.tag.type);\n        this.out(node.quasi, state,node.quasi.type);\n    },\n    ArrayExpression: ArrayExpression = function (node, state) {\n        state.write(node, '[');\n        if (node.elements.length > 0) {\n            var elements = node.elements, length = elements.length;\n            for (var i = 0; ; ) {\n                var element = elements[i];\n                element && this.expr(state,CommaList,element) ;\n\n                i += 1 ;\n                if (i < length || element===null)\n                    state.write(null, ',');\n                if (i >= length)\n                    break;\n                if (state.lineLength() > state.wrapColumn)\n                    state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel + 1));\n            }\n        }\n        state.write(null, ']');\n    },\n    ArrayPattern: ArrayExpression,\n    ObjectExpression: function (node, state) {\n        var property;\n        var indent = repeat(state.indent, state.indentLevel++);\n        var lineEnd = state.lineEnd;\n        var propertyIndent = indent + state.indent;\n        state.write(node, '{');\n        if (node.properties.length > 0) {\n            state.write(null, lineEnd);\n            var properties = node.properties, length = properties.length;\n            for (var i = 0; ; ) {\n                property = properties[i];\n                state.write(null, propertyIndent);\n                this.out(property, state,'Property');\n                if (++i < length)\n                    state.write(node, ',', lineEnd);\n                 else\n                    break;\n                if (state.lineLength() > state.wrapColumn)\n                    state.write(null, state.lineEnd, repeat(state.indent, state.indentLevel + 1));\n            }\n            state.write(null, lineEnd, indent, '}');\n        } else {\n            state.write(null, '}');\n        }\n        state.indentLevel--;\n    },\n    Property: function (node, state) {\n        if (node.method || (node.kind === 'get' || node.kind === 'set')) {\n            this.MethodDefinition(node, state);\n        } else {\n            if (!node.shorthand) {\n                if (node.computed) {\n                    state.write(null, '[');\n                    this.out(node.key, state,node.key.type);\n                    state.write(null, ']');\n                } else {\n                    this.out(node.key, state,node.key.type);\n                }\n                state.write(null, ': ');\n            }\n            this.expr(state,CommaList,node.value);\n        }\n    },\n    ObjectPattern: function (node, state) {\n        state.write(node, '{');\n        if (node.properties.length > 0) {\n            var properties = node.properties, length = properties.length;\n            for (var i = 0; ; ) {\n                this.out(properties[i], state,'Property');\n                if (++i < length)\n                    state.write(null, ', ');\n                 else\n                    break;\n            }\n        }\n        state.write(null, '}');\n    },\n    SequenceExpression: function (node, state) {\n        var expression;\n        var expressions = node.expressions;\n        if (expressions.length > 0) {\n            var length = expressions.length;\n            for (var i = 0; i<length; i++) {\n                expression = expressions[i];\n                if (i)\n                \tstate.write(null, ', ') ;\n                this.expr(state,CommaList,expression) ;\n            }\n        }\n    },\n    UnaryExpression: function (node, state) {\n        if (node.prefix) {\n            state.write(node, node.operator);\n            if (node.operator.length > 1)\n                state.write(node, ' ');\n            this.expr(state, node, node.argument, true);\n        } else {\n            this.expr(state, node, node.argument);\n            state.write(node, node.operator);\n        }\n    },\n    UpdateExpression: function (node, state) {\n        if (node.prefix) {\n            state.write(node, node.operator);\n            this.out(node.argument, state,node.argument.type);\n        } else {\n            this.out(node.argument, state,node.argument.type);\n            state.write(node, node.operator);\n        }\n    },\n    BinaryExpression: BinaryExpression = function (node, state) {\n        var operator = node.operator;\n        if (operator==='in' && state.inForInit)\n          state.write(null, '(');\n        this.expr(state, node, node.left);\n        state.write(node, ' ', operator, ' ');\n        this.expr(state, node, node.right, node.right.type==='ArrowFunctionExpression'?2:0);\n        if (operator==='in' && state.inForInit)\n          state.write(null, ')');\n    },\n    LogicalExpression: BinaryExpression,\n    AssignmentExpression: function (node, state) {\n      if (node.left.type==='ObjectPattern')\n        state.write(null,'(');\n      this.BinaryExpression(node,state);\n      if (node.left.type==='ObjectPattern')\n        state.write(null,')');\n    },\n    AssignmentPattern: function (node, state) {\n        this.expr(state, node, node.left);\n        state.write(node, ' = ');\n        this.expr(state, node, node.right);\n    },\n    ConditionalExpression: function (node, state) {\n        this.expr(state, node, node.test, true);\n        state.write(node, ' ? ');\n        this.expr(state, node, node.consequent);\n        state.write(null, ' : ');\n        this.expr(state, node, node.alternate);\n    },\n    NewExpression: function (node, state) {\n        state.write(node, 'new ');\n        this.out(node, state,'CallExpression');\n    },\n    CallExpression: function (node, state) {\n        this.expr(state, node, node.callee, node.callee.type==='ObjectExpression'?2:0);\n        state.write(node, '(');\n        var args = node['arguments'];\n        if (args.length > 0) {\n            var length = args.length;\n            for (var i = 0; i < length; i++) {\n                if (i!=0)\n                \tstate.write(null, ', ');\n               \tthis.expr(state,CommaList,args[i]) ;\n            }\n        }\n        state.write(null, ')');\n    },\n    MemberExpression: function (node, state) {\n    \tvar requireParens = (node.object.type === 'ObjectExpression' || (node.object.type.match(/Literal$/) && node.object.raw.match(/^[0-9]/))) ;\n        var noParens = !requireParens &&\n        \t((node.object.type === 'ArrayExpression' || node.object.type === 'CallExpression' || node.object.type === 'NewExpression')\n        \t|| precedence(node) <= precedence(node.object));\n        if (noParens) {\n            this.out(node.object, state,node.object.type);\n        } else {\n            state.write(null, '(');\n            this.out(node.object, state,node.object.type);\n            state.write(null, ')');\n        }\n        if (node.computed) {\n            state.write(node, '[');\n            this.out(node.property, state,node.property.type);\n            state.write(null, ']');\n        } else {\n            state.write(node, '.');\n            this.out(node.property, state,node.property.type);\n        }\n    },\n    Identifier: function (node, state) {\n        state.write(node, node.name);\n    },\n    Literal: function (node, state) {\n        state.write(node, node.raw);\n    },\n    NullLiteral:function (node, state) {\n        state.write(node, 'null');\n    },\n    BooleanLiteral:function (node, state) {\n        state.write(node, JSON.stringify(node.value));\n    },\n    StringLiteral:function (node, state) {\n        state.write(node, JSON.stringify(node.value));\n    },\n    RegExpLiteral:function (node, state) {\n        state.write(node, node.extra.raw || ('/'+node.pattern+'/'+node.flags));\n    },\n    NumericLiteral:function (node, state) {\n        state.write(node, JSON.stringify(node.value));\n    },\n};\nmodule.exports = function (node, options, originalSource) {\n    options = options || {};\n    var buffer = \"\", lines = [];\n    var map = options.map && new SourceMapGenerator(options.map);\n    if (map && options.map.sourceContent) {\n        map.setSourceContent(options.map.file, options.map.sourceContent);\n    }\n    var backBy = \"\";\n    var leadingComments = [];\n    var trailingComments = [];\n    function write(node) {\n        backBy = arguments[arguments.length - 1] ;\n        for (var i = 1; i < arguments.length; i++) {\n            if (map && node && node.loc && node.loc.start) {\n                var startOfLine = false;\n                map.addMapping({\n                    source: options.map.file,\n                    original: {\n                        line: node.loc.start.line,\n                        column: startOfLine ? 0 : node.loc.start.column\n                    },\n                    generated: {\n                        line: options.map.startLine + lines.length + 1,\n                        column: startOfLine ? 0 : buffer.length\n                    }\n                });\n            }\n            if (arguments[i] === st.lineEnd) {\n                if (trailingComments.length) {\n                    trailingComments.forEach(function (c) {\n                        if (c.type === 'Line')\n                            buffer += \" // \" + c.value;\n                         else {\n                            (\" /*\" + c.value + \"*/\").split(\"\\n\").forEach(function (v) {\n                                buffer += v;\n                                lines.push(buffer);\n                                buffer = \"\";\n                            });\n                            buffer = lines.pop();\n                        }\n                    });\n                    trailingComments = [];\n                }\n                lines.push(buffer);\n                buffer = \"\";\n                if (leadingComments.length) {\n                    var preceeding = lines.pop();\n                    leadingComments.forEach(function (c) {\n                        var indent = repeat(st.indent, c.indent);\n                        if (c.type === \"Line\")\n                            lines.push(indent + \"//\" + c.value);\n                         else\n                            (indent + \"/*\" + c.value + \"*/\").split(\"\\n\").forEach(function (l) {\n                            lines.push(l);\n                        });\n                    });\n                    lines.push(preceeding);\n                    leadingComments = [];\n                }\n            } else {\n                buffer += arguments[i];\n                if (node && node.$comments) {\n                    node.$comments.forEach(function (c) {\n                        var trailing = node.loc.start.column < c.loc.start.column;\n                        c.indent = st.indentLevel;\n                        if (trailing) {\n                            trailingComments.push(c);\n                        } else {\n                            leadingComments.push(c);\n                        }\n                    });\n                    node.$comments = null;\n                }\n            }\n        }\n    }\n    function lineLength() {\n        return buffer.length;\n    }\n    function sourceAt(start, end) {\n        return originalSource?originalSource.substring(start,end):\"/* Omitted Non-standard node */\" ;\n    }\n    function back() {\n        buffer = buffer.substring(0, buffer.length - backBy.length);\n    }\n    var st = {\n        inForInit: 0,\n        lineLength: lineLength,\n        sourceAt:sourceAt,\n        write: write,\n        back: back,\n        indent: \"    \",\n        lineEnd: \"\\n\",\n        indentLevel: 0,\n        wrapColumn: 80\n    };\n    traveler.out(node, st);\n    trailingComments = node.$comments || [];\n    st.write(node, st.lineEnd);\n    var result = lines.join(st.lineEnd);\n    if (options && options.map) {\n        return {\n            code: result,\n            map: map\n        };\n    }\n    return result;\n};\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/lib/parser.js":"'use strict';\n\nvar acorn = require(\"acorn\");\nvar acornWalk = require(\"acorn/dist/walk\");\n\nvar walkers = {\n    AwaitExpression: function (node, st, c) {\n        c(node.argument, st, \"Expression\");\n    },\n    SwitchStatement: function (node, st, c) {\n        c(node.discriminant, st, \"Expression\");\n        for (var i = 0; i < node.cases.length; ++i) {\n            c(node.cases[i],st) ;\n        }\n    },\n    SwitchCase: function (node, st, c) {\n        if (node.test) c(node.test, st, \"Expression\");\n        for (var i = 0; i < node.consequent.length; ++i) {\n            c(node.consequent[i], st, \"Statement\");\n        }\n    },\n    TryStatement: function (node, st, c) {\n        c(node.block, st, \"Statement\");\n        if (node.handler) c(node.handler, st, \"Statement\");\n        if (node.finalizer) c(node.finalizer, st, \"Statement\");\n    },\n    CatchClause: function (node, st, c) {\n        c(node.param, st, \"Pattern\");\n        c(node.body, st, \"ScopeBody\");\n    },\n    Class: function (node, st, c) {\n        if (node.id) c(node.id, st, \"Pattern\");\n        if (node.superClass) c(node.superClass, st, \"Expression\");\n        c(node.body, st);\n    },\n    ClassBody: function(node, st, c){\n        for (var i = 0; i < node.body.length; i++) {\n            c(node.body[i], st);\n        }\n    },\n    /* Babel extensions */\n    ClassProperty: function(node,st,c){\n        if (node.key) c(node.key, st, \"Expression\");\n        if (node.value) c(node.value, st, \"Expression\");\n    },\n    ClassMethod: function(node,st,c){\n        if (node.key) c(node.key, st, \"Expression\");\n        c(node, st, \"Function\");\n    },\n    ObjectProperty: function(node,st,c){\n        if (node.key) c(node.key, st, \"Expression\");\n        if (node.value) c(node.value, st, \"Expression\");\n    },\n    ObjectMethod: function(node,st,c){\n        if (node.key) c(node.key, st, \"Expression\");\n        c(node, st, \"Function\");\n    }\n} ;\n\nvar acornBase = acornWalk.make(walkers) ;\n\nfunction loc(old,repl){\n    ['start','end','loc','range'].forEach(function(k){\n        if (k in old && !(k in repl))\n            repl[k] = old[k] ;\n    }) ;\n}\n\nvar referencePrototypes = {\n    replace: function(newNode) {\n        if (Array.isArray(newNode) && newNode.length===1) newNode = newNode[0] ;\n        if ('index' in this) {\n            loc(this.parent[this.field][this.index], newNode);\n            if (Array.isArray(newNode)) {\n                [].splice.apply(this.parent[this.field],[this.index,1].concat(newNode)) ;\n            } else {\n                this.parent[this.field][this.index] = newNode ;\n            }\n        } else {\n            loc(this.parent[this.field], newNode);\n            if (Array.isArray(newNode)) {\n                this.parent[this.field] = {type:'BlockStatement',body:newNode} ;\n            } else {\n                this.parent[this.field] = newNode ;\n            }\n        }\n        return this.self ;\n    },\n    append: function(newNode) {\n        if (Array.isArray(newNode) && newNode.length===1) newNode = newNode[0] ;\n        if ('index' in this) {\n            if (Array.isArray(newNode)) {\n                [].splice.apply(this.parent[this.field],[this.index+1,0].concat(newNode)) ;\n            } else {\n                this.parent[this.field].splice(this.index+1,0,newNode) ;\n            }\n        } else {\n            throw new Error(\"Cannot append Element node to non-array\") ;\n        }\n        return this.self ;\n    },\n    index: function(){\n        return this.parent[this.field].indexOf(this.self) ;\n    },\n    removeElement: function() {\n        return this.parent[this.field].splice(this.index,1)[0] ;\n    },\n    removeNode: function() {\n        var r = this.parent[this.field] ;\n        delete this.parent[this.field] ;\n        return r ;\n    }\n};\n\nfunction treeWalker(n,walker,state){\n    if (!state) {\n        state = [{self:n}] ;\n        state.replace = function(pos,newNode) {\n            state[pos].replace(newNode) ;\n        }\n    }\n\n    function goDown(ref) {\n        ref.replace = referencePrototypes.replace ;\n        ref.append = referencePrototypes.append ;\n        if (ref.index) {\n            Object.defineProperties(ref, {index:{enumerable:true,get:referencePrototypes.index}}) ;\n            ref.remove = referencePrototypes.removeElement ;\n        } else {\n            ref.remove = referencePrototypes.removeNode ;\n        }\n        state.unshift(ref) ;\n        treeWalker(ref.self,walker,state) ;\n        state.shift() ;\n    }\n\n    function descend() {\n        if (!(n.type in acornBase)) {\n            // We don't know what type of node this is - it's not in the ESTree spec,\n            // (maybe a 'react' extension?), so just ignore it\n        } else {\n            acornBase[n.type](n,state,function down(sub,_,derivedFrom){\n                if (sub===n)\n                    return acornBase[derivedFrom || n.type](n,state,down) ;\n\n                var keys = Object.keys(n) ;\n                for (var i=0; i<keys.length; i++){\n                    var v = n[keys[i]] ;\n                    if (Array.isArray(v)) {\n                        if (v.indexOf(sub)>=0) {\n                            goDown({\n                                self:sub,\n                                parent:n,\n                                field:keys[i],\n                                index:true\n                            }) ;\n                        }\n                    } else if (v instanceof Object && sub===v) {\n                        goDown({\n                            self:sub,\n                            parent:n,\n                            field:keys[i]\n                        }) ;\n                    }\n                }\n            }) ;\n        }\n    } ;\n    walker(n,descend,state) ;\n    return n ;\n}\n\nvar alreadyInstalledPlugin = false ;\n\nfunction acornParse(code,config) {\n    var comments = [] ;\n    var options = {\n        ecmaVersion:8,\n        allowHashBang:true,\n        allowReturnOutsideFunction:true,\n        allowImportExportEverywhere:true,\n        locations:true,\n        onComment:comments\n    } ;\n\n    if (!(config && config.noNodentExtensions) || parseInt(acorn.version) < 4) {\n        if (!alreadyInstalledPlugin) {\n            if (parseInt(acorn.version) < 4)\n                console.warn(\"Nodent: Warning - noNodentExtensions option requires acorn >=v4.x. Extensions installed.\") ;\n            require('acorn-es7-plugin')(acorn) ;\n            alreadyInstalledPlugin = true ;\n        }\n        options.plugins = options.plugins || {} ;\n        options.plugins.asyncawait = {asyncExits:true, awaitAnywhere:true} ;\n    }\n    \n    if (config)\n        for (var k in config)\n            if (k !== 'noNodentExtensions')\n                options[k] = config[k] ;\n\n    var ast = acorn.parse(code,options) ;\n\n    // attach comments to the most tightly containing node\n    treeWalker(ast,function(node,descend,path){\n        descend() ;\n        while (comments.length && node.loc &&\n            (node.loc.start.line >= comments[0].loc.start.line && node.loc.end.line>=comments[0].loc.end.line)) {\n            node.$comments = node.$comments||[] ;\n            node.$comments.push(comments.shift()) ;\n        }\n    }) ;\n    return ast ;\n}\n\nvar parseCache = {} ;\nfunction partialParse(code,args) {\n  if (!parseCache[code]) {\n    parseCache[code] = acornParse(code,{\n      noNodentExtensions:true, // The partial parser only ever parses ES5\n      locations:false,\n      ranges:false,\n      onComment:null\n    }) ;\n  }\n\n  var result = substitute(parseCache[code]) ;\n  return {body:result.body, expr:result.body[0].type==='ExpressionStatement' ? result.body[0].expression : null} ;\n\n  /* parse and substitute:\n   * \n   *    $1      Substitute the specified expression. If $1 occupies a slot which is an array of expressions (e.g arguments, params)\n   *            and the passed argument is an array, subtitute the whole set\n   *    {$:1}   Substitute a single statement \n   * \n   */\n  function substitute(src,dest) {\n    if (Array.isArray(dest) && !Array.isArray(src))\n        throw new Error(\"Can't substitute an array for a node\") ;\n    \n    dest = dest || {} ;\n    Object.keys(src).forEach(function(k){\n      if (!(src[k] instanceof Object))\n          return dest[k] = src[k] ;\n\n      function moreNodes(v){ if (typeof v===\"function\") v = v() ; dest = dest.concat(v) ; return dest };\n      function copyNode(v){ if (typeof v===\"function\") v = v() ; dest[k] = v ; return dest };\n\n      // The src is an array, so create/grow the destination\n      // It could an an array of expressions $1,$2,$3 or statements $:1;$:2;$:3;\n      if (Array.isArray(src[k]))\n          return dest[k] = substitute(src[k],[]) ;\n\n      var p ;\n      if (Array.isArray(dest)) \n          p = moreNodes ;\n      else\n          p = copyNode ;\n          \n      // Substitute a single identifier $.. with an expression (TODO: test provided arg is an expression node)\n      if (src[k].type==='Identifier' && src[k].name[0]==='$') \n          return p(args[src[k].name.slice(1)]) ;\n\n      // Substitute a single labeled statement $:.. with a statement (TODO: test provided arg is a statement node)\n      if (src[k].type === 'LabeledStatement' && src[k].label.name==='$') { \n          var spec = src[k].body.expression ;\n          return p(args[spec.name || spec.value]) ;\n      }\n\n      // Magic label to set call a function to modify a statement node  $$method: <statement>\n      // The newNode = args.method(oldNode)\n      if (src[k].type === 'LabeledStatement' && src[k].label.name.slice(0,2)==='$$') { \n          return p(args[src[k].label.name.slice(2)](substitute(src[k]).body)) ;\n      }\n      \n      return p(substitute(src[k])) ;\n    }) ;\n    return dest ;\n  }\n}\n\nmodule.exports = {\n    part:partialParse,\n    parse: acornParse,\n    treeWalker:treeWalker\n} ;\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/lib/arboriculture.js":"'use strict';\n\n/* We manipulate (abstract syntax) trees */\nvar parser = require('./parser');\nvar outputCode = require('./output');\n/** Helpers **/\nglobal.printNode = function printNode(n) {\n    if (!n) return '' ;\n    if (Array.isArray(n))\n        return n.map(printNode).join(\"|\\n\");\n    try {\n        return outputCode(n) ; //+\"\\t//@\"+Object.keys(n).filter(function(k){ return k[0]==='$'}).map(function(k){ return k+\":\"+n[k] });\n    } catch (ex) {\n        return ex.message + \": \" + (n && n.type);\n    }\n}\n\nfunction cloneNode(n) {\n    if (Array.isArray(n))\n        return n.map(function (n) {\n        return cloneNode(n);\n    });\n    var o = {};\n    Object.keys(n).forEach(function (k) {\n        o[k] = n[k];\n    });\n    return o;\n}\n\n/* Bit of a hack: without having to search for references to this\n * node, force it to be some replacement node */\nvar locationInfo = { start:true, end: true, loc: true, range: true } ;\nfunction coerce(node, replace) {\n    if (node===replace) return ;\n    node.__proto__ = Object.getPrototypeOf(replace);\n    Object.keys(node).forEach(function (k) {\n        if (!(k in locationInfo))\n            delete node[k];\n    });\n    Object.keys(replace).forEach(function (k) {\n        if (!(k in node))\n            node[k] = replace[k];\n    });\n}\n\nfunction Nothing(){}\n\nvar examinations = {\n        getScope: function(){ return  this.node.type === 'FunctionDeclaration' || this.node.type === 'FunctionExpression' || this.node.type === 'Function' || this.node.type === 'ObjectMethod' || this.node.type === 'ClassMethod' || (this.node.type === 'ArrowFunctionExpression' && this.node.body.type === 'BlockStatement') ? this.node.body.body : this.node.type === 'Program' ? this.node.body : null},\n        isScope: function(){ return  this.node.type === 'FunctionDeclaration' || this.node.type === 'FunctionExpression' || this.node.type === 'Function' || this.node.type === 'Program' || this.node.type === 'ObjectMethod' || this.node.type === 'ClassMethod' || (this.node.type === 'ArrowFunctionExpression' && this.node.body.type === 'BlockStatement')},\n        isFunction: function(){ return  this.node.type === 'FunctionDeclaration' || this.node.type === 'FunctionExpression' || this.node.type === 'Function' || this.node.type === 'ObjectMethod' || this.node.type === 'ClassMethod' || this.node.type === 'ArrowFunctionExpression'},\n        isClass: function(){ return  this.node.type === 'ClassDeclaration' || this.node.type === 'ClassExpression'},\n        isBlockStatement: function(){ return this.node.type==='ClassBody' ||  this.node.type === 'Program' || this.node.type === 'BlockStatement' ? this.node.body : this.node.type === 'SwitchCase' ? this.node.consequent : false},\n        isExpressionStatement: function(){ return  this.node.type === 'ExpressionStatement'},\n        isLiteral: function(){ return  this.node.type === 'Literal' || this.node.type === 'BooleanLiteral' || this.node.type === 'RegExpLiteral' || this.node.type === 'NumericLiteral' || this.node.type === 'StringLiteral' || this.node.type === 'NullLiteral'},\n        isDirective: function(){ return  this.node.type === 'ExpressionStatement' && (this.node.expression.type === 'StringLiteral' || this.node.expression.type === 'Literal' && typeof this.node.expression.value === 'string')},\n        isUnaryExpression: function(){ return  this.node.type === 'UnaryExpression'},\n        isAwait: function(){ return  this.node.type === 'AwaitExpression' && !this.node.$hidden},\n        isAsync: function(){ return  this.node.async },\n        isStatement: function(){ return  this.node.type.match(/[a-zA-Z]+Declaration/) !== null || this.node.type.match(/[a-zA-Z]+Statement/) !== null},\n        isExpression: function(){ return  this.node.type.match(/[a-zA-Z]+Expression/) !== null},\n        isLoop: function(){ return  this.node.type === 'ForStatement' || this.node.type === 'WhileStatement' || this.node.type === 'DoWhileStatement'}, //   Other loops?\n        isJump: function(){ return  this.node.type === 'ReturnStatement' || this.node.type === 'ThrowStatement' || this.node.type === 'BreakStatement' || this.node.type === 'ContinueStatement'},\n        isES6: function(){\n          switch (this.node.type) {\n            case 'ExportNamedDeclaration':\n            case 'ExportSpecifier':\n            case 'ExportDefaultDeclaration':\n            case 'ExportAllDeclaration':\n            case 'ImportDeclaration':\n            case 'ImportSpecifier':\n            case 'ImportDefaultSpecifier':\n            case 'ImportNamespaceSpecifier':\n            case 'ArrowFunctionExpression':\n            case 'ForOfStatement':\n            case 'YieldExpression':\n            case 'Super':\n            case 'RestElement':\n            case 'RestProperty':\n            case 'SpreadElement':\n            case 'TemplateLiteral':\n            case 'ClassDeclaration':\n            case 'ClassExpression':\n              return true ;\n\n            case 'VariableDeclaration':\n              return this.node.kind && this.node.kind !== 'var' ;\n\n            case 'FunctionDeclaration':\n            case 'FunctionExpression':\n              return !!this.node.generator;\n        }\n      }\n};\n\nvar NodeExaminer = {} ;\nObject.keys(examinations).forEach(function(k){\n    Object.defineProperty(NodeExaminer,k,{\n        get:examinations[k]\n    }) ;\n}) ;\n\nfunction examine(node) {\n    if (!node)\n        return {};\n    NodeExaminer.node = node ;\n    return NodeExaminer ;\n}\n\n/*\n * descendOn = true                     Enter scopes within scopes\n * descendOn = false/undefined/null     Do not enter scopes within scopes\n * descendOn = function                 Descend when function(node) is true\n */\nfunction contains(ast, fn, descendOn) {\n    if (!ast)\n        return null;\n    if (fn && typeof fn === 'object') {\n        var keys = Object.keys(fn);\n        return contains(ast, function (node) {\n            return keys.every(function (k) {\n                return node[k] == fn[k];\n            });\n        });\n    }\n    var n, found = {};\n    if (Array.isArray(ast)) {\n        for (var i = 0;i < ast.length; i++)\n            if (n = contains(ast[i], fn))\n                return n;\n        return null;\n    }\n\n    var subScopes = descendOn ;\n    if (typeof descendOn !== \"function\") {\n        if (descendOn) {\n            subScopes = function(n) { return true } ;\n        } else {\n            subScopes = function(n) { return !examine(n).isScope } ;\n        }\n    }\n\n    try {\n        parser.treeWalker(ast, function (node, descend, path) {\n            if (fn(node)) {\n                found.path = path;\n                throw found;\n            }\n            if (node === ast || subScopes(node))\n                descend();\n        });\n    } catch (ex) {\n        if (ex === found)\n            return found.path;\n        throw ex;\n    }\n    return null;\n}\n\nfunction containsAwait(ast) {\n    return contains(ast, function(n){\n        return n.type==='AwaitExpression' && !n.$hidden\n    });\n}\n\nfunction containsAwaitInBlock(ast) {\n    return contains(ast, function(n){\n        return n.type==='AwaitExpression'  && !n.$hidden\n    }, function (n) {\n        var x = examine(n) ;\n        return !x.isBlockStatement && !x.isScope\n    });\n}\n\nfunction containsThis(ast) {\n    return contains(ast, {\n        type: 'ThisExpression'\n    });\n}\n\nfunction babelLiteralNode(value) {\n    if (value === null)\n        return {\n        type: 'NullLiteral',\n        value: null,\n        raw: 'null'\n    };\n    if (value === true || value === false)\n        return {\n        type: 'BooleanLiteral',\n        value: value,\n        raw: JSON.stringify(value)\n    };\n    if (value instanceof RegExp) {\n        var str = value.toString();\n        var parts = str.split('/');\n        return {\n            type: 'RegExpLiteral',\n            value: value,\n            raw: str,\n            pattern: parts[1],\n            flags: parts[2]\n        };\n    }\n    if (typeof value === 'number')\n        return {\n        type: 'NumericLiteral',\n        value: value,\n        raw: JSON.stringify(value)\n    };\n    return {\n        type: 'StringLiteral',\n        value: value,\n        raw: JSON.stringify(value)\n    };\n}\n\nfunction ident(name, loc) {\n    return {\n        type: 'Identifier',\n        name: name,\n        loc: loc\n    };\n}\n\nfunction idents(s) {\n    var r = {};\n    for (var k in s)\n        r[k] = typeof s[k] === \"string\" ? ident(s[k]) : s[k];\n    return r;\n}\n\nfunction asynchronize(pr, __sourceMapping, opts, logger) {\n    var continuations = {};\n    var generatedSymbol = 1;\n    var genIdent = {};\n    Object.keys(opts).filter(function (k) {\n        return k[0] === '$';\n    }).forEach(function (k) {\n        genIdent[k.slice(1)] = ident(opts[k]);\n    });\n\n    /* Generate a prototypical call of the form:\n     *      (left).$asyncbind(this,...args)\n     */\n    function bindAsync(left,arg) {\n        if (opts.es6target && !left.id && !arg && left.type.indexOf(\"Function\")===0) {\n            left.type = 'ArrowFunctionExpression' ;\n            return left ;\n        }\n\n        if (opts.noRuntime) {\n            if (arg) {\n                if (examine(arg).isLiteral) {\n                    throw new Error(\"Nodent: 'noRuntime' option only compatible with -promise and -engine modes\") ;\n                }\n                // Add a global synchronous exception handler to (left)\n                left.body.body = parser.part(\"try {$:0} catch($2) {return $1($2)}\",[cloneNode(left.body),arg,ident('$boundEx')]).body ;\n            } else if (opts.es6target && !left.id && left.type.indexOf(\"Function\")===0) {\n                left.type = 'ArrowFunctionExpression' ;\n                return left ;\n            }\n            if (opts.es6target && !left.id) {\n                left.type = 'ArrowFunctionExpression' ;\n                return left;\n            }\n            return parser.part(\"$0.bind(this)\",[left]).expr;\n        }\n\n        var params = [{ \"type\": \"ThisExpression\" }] ;\n        if (arg) {\n          return parser.part(\"$0.$1(this,$2)\",[left,genIdent.asyncbind,arg]).expr;\n        }\n        return parser.part(\"$0.$1(this)\",[left,genIdent.asyncbind]).expr;\n    }\n\n    function makeBoundFn(name, body, argnames, binding) {\n        return parser.part(\"var $0 = $1\",[ident(name),bindAsync({\n                    \"type\": \"FunctionExpression\",\n                    \"id\": null,\n                    \"generator\": false,\n                    \"expression\": false,\n                    \"params\": argnames || [],\n                    \"body\": Array.isArray(body)?{type:'BlockStatement',body:body}:body\n                }, binding)]).body[0] ;\n    }\n\n    function where(node) {\n        return pr.filename + (node && node.loc && node.loc.start ? \"(\" + node.loc.start.line + \":\" + node.loc.start.column + \")\\t\" : \"\\t\");\n    }\n\n    function literal(value) {\n        if (opts.babelTree) {\n            return babelLiteralNode(value);\n        } else {\n            return {\n                type: 'Literal',\n                value: value,\n                raw: JSON.stringify(value)\n            };\n        }\n    }\n\n    function getMemberFunction(node) {\n        if (!node)\n            return null ;\n        if (opts.babelTree && (node.type === 'ClassMethod' || node.type === 'ObjectMethod')) {\n            return node;\n        } else if ((!opts.babelTree && node.type === 'MethodDefinition' || node.type === 'Property' && (node.method || node.kind == 'get' || node.kind == 'set')) && examine(node.value).isFunction) {\n            return node.value;\n        }\n        return null;\n    }\n\n    var assign$Args = parser.part(\"var $0 = arguments\",[genIdent.arguments]).body[0] ;\n\n    /* Replace 'arguments' identifiers in a function. Return true if a\n     * replacement has been made and so the symbol opts.$arguments needs\n     * initializing.\n     */\n    function replaceArguments(ast,nested) {\n        if (!examine(ast).isFunction)\n            throw new Error(\"Can only replace 'arguments' in functions\") ;\n\n        if (!('$usesArguments' in ast)) {\n            parser.treeWalker(ast, function (node, descend, path) {\n                if (node.type === 'Identifier' && node.name === 'arguments') {\n                    // Fix up shorthand properties\n                    if (path[0].parent.shorthand) {\n                      path[0].parent.shorthand = false ;\n                      path[0].parent.key = ident('arguments') ;\n                      ast.$usesArguments = true ;\n                    }\n    \n                    // Replace identifiers that are not keys\n                    if (path[0].field !== 'key') {\n                      node.name = opts.$arguments;\n                      ast.$usesArguments = true ;\n                    }\n                } else if (node === ast || !examine(node).isFunction) {\n                  descend();\n                } else if (node.type==='ArrowFunctionExpression') {\n                    replaceArguments(node) ;\n                    ast.$usesArguments = ast.$usesArguments || node.$usesArguments ;\n                }\n            });\n            ast.$usesArguments = ast.$usesArguments || false ;\n        }\n        return ast.$usesArguments && ast.type !== 'ArrowFunctionExpression';\n    }\n\n    function generateSymbol(node) {\n        if (typeof node != 'string')\n            node = node.type.replace(/Statement|Expression/g,\"\");\n        return opts.generatedSymbolPrefix + node + \"_\" + generatedSymbol++;\n    }\n\n    function setExit(n, sym) {\n        if (n) {\n            n.$exit = idents({\n                $error: sym.$error,\n                $return: sym.$return\n            });\n        }\n        return n;\n    }\n\n    function getExitNode(path) {\n        for (var n = 0;n < path.length; n++) {\n            if (path[n].self.$exit) {\n                return path[n].self;\n            }\n            if (path[n].parent && path[n].parent.$exit) {\n                return path[n].parent;\n            }\n        }\n        return null;\n    }\n\n    function getExit(path, parents) {\n        var n = getExitNode(path);\n        if (n)\n            return n.$exit;\n        if (parents) {\n            for (var i = 0;i < parents.length; i++)\n                if (parents[i])\n                return idents(parents[i]);\n        }\n        return null;\n    }\n\n    // actually do the transforms\n    if (opts.engine) {\n        // Only Transform extensions:\n        // - await outside of async\n        // - async return <optional-expression>\n        // - async throw <expression>\n        // - get async id(){} / async get id(){}\n        // - super references (in case they are used by async exits - in general they aren't)\n        // Everything else is passed through unmolested to be run by a JS engine such as V8 v5.4\n        pr.ast = fixSuperReferences(pr.ast,true);\n        pr.ast = asyncSpawn(pr.ast, opts.engine);\n        pr.ast = exposeCompilerOpts(pr.ast);\n        cleanCode(pr.ast)\n    } else if (opts.generators) {\n        // Transform to generators\n        pr.ast = fixSuperReferences(pr.ast);\n        pr.ast = asyncSpawn(pr.ast);\n        pr.ast = exposeCompilerOpts(pr.ast);\n        cleanCode(pr.ast)\n    } else {\n        // Transform to callbacks, optionally with Promises\n        pr.ast = fixSuperReferences(pr.ast);\n        asyncTransforms(pr.ast);\n    }\n    if (opts.babelTree) {\n        parser.treeWalker(pr.ast, function (node, descend, path) {\n            descend();\n            if (node.type === 'Literal') {\n                coerce(node, literal(node.value));\n            }\n        });\n    }\n    return pr;\n\n    function asyncTransforms(ast, awaitFlag) {\n        var useLazyLoops = !(opts.promises || opts.generators || opts.engine) && opts.lazyThenables ;\n        // Because we create functions (and scopes), we need all declarations before use\n        blockifyArrows(ast);\n        hoistDeclarations(ast);\n        // All TryCatch blocks need a name so we can (if necessary) find out what the enclosing catch routine is called\n        labelTryCatch(ast);\n        // Convert async functions and their contained returns & throws\n        asyncDefine(ast);\n        asyncDefineMethod(ast);\n        // Loops are asynchronized in an odd way - the loop is turned into a function that is\n        // invoked through tail recursion OR callback. They are like the inner functions of\n        // async functions to allow for completion and throwing\n        (useLazyLoops?asyncLoops_1:Nothing)(ast);\n        // Handle the various JS control flow keywords by splitting into continuations that could\n        // be invoked asynchronously\n        mapLogicalOp(ast);\n        mapCondOp(ast);\n        walkDown(ast, [mapTryCatch,(useLazyLoops?Nothing:mapLoops),mapIfStmt,mapSwitch,mapBlock]);\n        // Map awaits by creating continuations and passing them into the async resolver\n        asyncAwait(ast, awaitFlag);\n        exposeCompilerOpts(ast);\n        // Remove guff generated by transpiling\n        cleanCode(ast);\n    }\n\n    /* Create a 'continuation' - a block of statements that have been hoisted\n     * into a named function so they can be invoked conditionally or asynchronously */\n    function makeContinuation(name, body) {\n        var ctn = {\n            $continuation: true,\n            type: name?'FunctionDeclaration':'FunctionExpression',\n                id: name?typeof name===\"string\"?ident(name):name:undefined,\n                    params: [],\n                    body: {\n                        type: 'BlockStatement',\n                        body: cloneNode(body)\n                    }\n        };\n        if (name) {\n            continuations[name] = {\n                def: ctn\n            };\n        }\n        return ctn;\n    }\n\n    /* Generate an expression AST the immediate invokes the specified async function, e.g.\n     *      (await ((async function(){ ...body... })()))\n     */\n    function internalIIAFE(body) {\n        return {\n            type: 'AwaitExpression',\n            argument: asyncDefine({\n                \"type\": \"FunctionExpression\",\n                \"generator\": false,\n                \"expression\": false,\n                \"async\": true,\n                \"params\": [],\n                \"body\": {\n                    \"type\": \"BlockStatement\",\n                    \"body\": body\n                }\n            }).body.body[0].argument\n        }\n    }\n\n    /* Used to invoke a 'continuation' - a function that represents\n     * a block of statements lifted out so they can be labelled (as\n     * a function definition) to be invoked via multiple execution\n     * paths - either conditional or asynchronous. Since 'this' existed\n     * in the original scope of the statements, the continuation function\n     * must also have the correct 'this'.*/\n    function thisCall(name, args) {\n        if (typeof name === 'string')\n            name = ident(name);\n        var n = parser.part(\"$0.call($1)\",[name,[{\"type\": \"ThisExpression\"}].concat(args || [])]).expr ;\n        name.$thisCall = n;\n        n.$thisCallName = name.name;\n        return n;\n    }\n    function returnThisCall(name,args) {\n        return {\n            type:'ReturnStatement',\n            argument: thisCall(name,args)\n        }\n    }\n\n    function deferredFinally(node, expr) {\n        return {\n            \"type\": \"CallExpression\",\n            \"callee\": ident(node.$seh + \"Finally\"),\n            \"arguments\": expr ? [expr] : []\n        };\n    }\n\n    /**\n     * returnMapper is an Uglify2 transformer that is used to change statements such as:\n     *     return some-expression ;\n     * into\n     *     return $return(some-expression) ;\n     * for the current scope only -i.e. returns nested in inner functions are NOT modified.\n     *\n     * This allows us to capture a normal \"return\" statement and actually implement it\n     * by calling the locally-scoped function $return()\n     */\n    function mapReturns(n, path) {\n        if (Array.isArray(n)) {\n            return n.map(function (m) {\n                return mapReturns(m, path);\n            });\n        }\n        var lambdaNesting = 0;\n        var tryNesting = 0 ;\n        return parser.treeWalker(n, function (node, descend, path) {\n            if (node.type === 'ReturnStatement' && !node.$mapped) {\n                if (lambdaNesting > 0) {\n                    if (!examine(node).isAsync) {\n                        return descend(node);\n                    }\n                    delete node.async;\n                }\n                /* NB: There is a special case where we do a REAL return to allow for chained async-calls and synchronous returns\n                 *\n                 * The selected syntax for this is:\n                 *   return void (expr) ;\n                 * which is mapped to:\n                 *   return (expr) ;\n                 *\n                 * Note that the parenthesis are necessary in the case of anything except a single symbol as \"void\" binds to\n                 * values before operator. In the case where we REALLY want to return undefined to the callback, a simple\n                 * \"return\" or \"return undefined\" works.\n                 *\n                 * There is an argument for only allowing this exception in es7 mode, as Promises and generators might (one day)\n                 * get their own cancellation method.\n                 * */\n                node.$mapped = true;\n                if (examine(node.argument).isUnaryExpression && node.argument.operator === \"void\") {\n                    node.argument = node.argument.argument;\n                } else {\n                    node.argument = {\n                        \"type\": \"CallExpression\",\n                        callee: getExit(path, [opts]).$return,\n                        \"arguments\": node.argument ? [node.argument] : []\n                    };\n                }\n                return;\n            } else if (node.type === 'ThrowStatement') {\n                var isAsync = examine(node).isAsync ;\n                if (lambdaNesting > 0) {\n                    if (!isAsync) {\n                        return descend(node);\n                    }\n                    delete node.async;\n                }\n                if (!isAsync && tryNesting) {\n                    descend() ;\n                } else {\n                  node.type = 'ReturnStatement';\n                  node.$mapped = true;\n                  node.argument = {\n                      type: 'CallExpression',\n                      callee: getExit(path, [opts]).$error,\n                      arguments: [node.argument]\n                  };\n                }\n                return;\n            } else if (node.type === 'TryStatement') {\n              tryNesting++;\n              descend(node);\n              tryNesting--;\n              return;\n            } else if (examine(node).isFunction) {\n                lambdaNesting++;\n                descend(node);\n                lambdaNesting--;\n                return;\n            } else {\n                descend(node);\n                return;\n            }\n        }, path);\n    }\n\n    /*\n    To implement conditional execution, a?b:c is mapped to\n\n      await (async function(){ if (a) return b ; return c })\n\n      Note that 'await (async function(){})()' can be optimized to a Thenable since no args are passed\n   */\n    function mapCondOp(ast, state) {\n        if (Array.isArray(ast))\n            return ast.map(function (n) {\n            return mapCondOp(n, state);\n        });\n        parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            if (node.type === 'ConditionalExpression' && (containsAwait(node.alternate) || containsAwait(node.consequent))) {\n                var z = ident(generateSymbol(\"condOp\"));\n                var xform = internalIIAFE(parser.part(\"if ($0) return $1 ; return $2\",[node.test,node.consequent,node.alternate]).body);\n                coerce(node, xform);\n            }\n        }, state);\n        return ast;\n    }\n\n    /*\n      To implement conditional execution, logical operators with an awaited RHS are mapped thus:\n\n        Translate a || b into await (async function Or(){ var z ; if (!(z=a)) z=b ; return z })\n        Translate a && b into await (async function And(){ var z ; if (z=a) z=b ; return z })\n\n        Note that 'await (async function(){})()' can be optimized to a Thenable since no args are passed\n     */\n    function mapLogicalOp(ast, state) {\n        if (Array.isArray(ast))\n            return ast.map(function (n) {\n            return mapLogicalOp(n, state);\n        });\n        parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            if (node.type === 'LogicalExpression' && containsAwait(node.right)) {\n                var codeFrag;\n                var z = ident(generateSymbol(\"logical\" + (node.operator === '&&' ? \"And\" : \"Or\")));\n\n                if (node.operator === '||') {\n                    codeFrag = \"var $0; if (!($0 = $1)) {$0 = $2} return $0\" ;\n                } else if (node.operator === '&&') {\n                    codeFrag = \"var $0; if ($0 = $1) {$0 = $2} return $0\" ;\n                } else\n                    throw new Error(where(node) + \"Illegal logical operator: \"+node.operator);\n\n                coerce(node, internalIIAFE(parser.part(codeFrag,[z,node.left, node.right]).body));\n            }\n        }, state);\n        return ast;\n    }\n\n    function mapBlock(block, path, down) {\n        if (block.type !== \"SwitchCase\" && examine(block).isBlockStatement) {\n            var idx = 0 ;\n            while (idx < block.body.length) {\n                var node = block.body[idx] ;\n                if (node.type !== \"SwitchCase\" && examine(node).isBlockStatement) {\n                    var blockScoped = containsBlockScopedDeclarations(node.body) ;\n                    if (!blockScoped) {\n                        block.body.splice.apply(block.body,[idx,1].concat(node.body));\n                    } else {\n                        if (containsAwaitInBlock(node)) {\n                            var symName = generateSymbol(node);\n                            var deferredCode = block.body.splice(idx + 1, block.body.length - (idx + 1));\n                            if (deferredCode.length) {\n                                var ctn = makeContinuation(symName, deferredCode);\n                                delete continuations[symName] ;\n                                node.body.push(returnThisCall(symName));\n                                block.body.push(ctn) ;\n                                idx++ ;\n                            } else idx++ ;\n                        } else idx++ ;\n                    }\n                } else idx++ ;\n            }\n        }\n    }\n\n    /*\n     * Translate:\n  if (x) { y; } more... ;\n     * into\n  if (x) { y; return $more(); } function $more() { more... } $more() ;\n     *\n     * ...in case 'y' uses await, in which case we need to invoke $more() at the end of the\n     * callback to continue execution after the case.\n     */\n    function mapIfStmt(ifStmt, path, down) {\n        if (ifStmt.type === 'IfStatement' && containsAwait([ifStmt.consequent,ifStmt.alternate])) {\n            var symName = generateSymbol(ifStmt);\n            var ref = path[0];\n            var synthBlock = {\n                type: 'BlockStatement',\n                body: [ifStmt]\n            };\n            if ('index' in ref) {\n                var idx = ref.index;\n                var deferredCode = ref.parent[ref.field].splice(idx + 1, ref.parent[ref.field].length - (idx + 1));\n                ref.replace(synthBlock);\n                if (deferredCode.length) {\n                    var call = returnThisCall(symName);\n                    synthBlock.body.push(down(makeContinuation(symName, deferredCode)));\n                    [ifStmt.consequent,ifStmt.alternate].forEach(function (cond) {\n                        if (!cond)\n                            return;\n                        var blockEnd;\n                        if (!examine(cond).isBlockStatement)\n                            blockEnd = cond;\n                         else\n                            blockEnd = cond.body[cond.body.length - 1];\n                        if (!(blockEnd && blockEnd.type === 'ReturnStatement')) {\n                            if (!(cond.type === 'BlockStatement')) {\n                                coerce(cond, {\n                                    type: 'BlockStatement',\n                                    body: [cloneNode(cond)]\n                                });\n                            }\n                            cond.$deferred = true;\n                            cond.body.push(cloneNode(call));\n                        }\n                        down(cond);\n                    });\n                    // If both blocks are transformed, the trailing call to $post_if()\n                    // can be omitted as it'll be unreachable via a synchronous path\n                    if (!(ifStmt.consequent && ifStmt.alternate && ifStmt.consequent.$deferred && ifStmt.alternate.$deferred))\n                        synthBlock.body.push(cloneNode(call));\n                }\n            } else {\n                ref.parent[ref.field] = synthBlock;\n            }\n        }\n    }\n\n    function mapSwitch(switchStmt, path, down) {\n        if (!switchStmt.$switched && switchStmt.type === 'SwitchStatement' && containsAwait(switchStmt.cases)) {\n            switchStmt.$switched = true;\n            var symName, deferred, deferredCode, ref = path[0];\n            if ('index' in ref) {\n                var j = ref.index + 1;\n                deferredCode = ref.parent[ref.field].splice(j, ref.parent[ref.field].length - j);\n                if (deferredCode.length && deferredCode[deferredCode.length - 1].type === 'BreakStatement')\n                    ref.parent[ref.field].push(deferredCode.pop());\n                symName = generateSymbol(switchStmt);\n                deferred = returnThisCall(symName);\n                ref.parent[ref.field].unshift(makeContinuation(symName, deferredCode));\n                ref.parent[ref.field].push(cloneNode(deferred));\n            }\n            // Now transform each case so that 'break' looks like return <deferred>\n            switchStmt.cases.forEach(function (caseStmt, idx) {\n                if (!(caseStmt.type === 'SwitchCase')) {\n                    throw new Error(\"switch contains non-case/default statement: \" + caseStmt.type);\n                }\n                if (containsAwait(caseStmt.consequent)) {\n                    var end = caseStmt.consequent[caseStmt.consequent.length - 1];\n                    if (end.type === 'BreakStatement') {\n                        caseStmt.consequent[caseStmt.consequent.length - 1] = cloneNode(deferred) ;\n                    } else if (end.type === 'ReturnStatement' || end.type === 'ThrowStatement') {} else {\n                        // Do nothing - block ends in return or throw\n                        logger(where(caseStmt) + \"switch-case fall-through not supported - added break. See https://github.com/MatAtBread/nodent#differences-from-the-es7-specification\");\n                        caseStmt.consequent.push(cloneNode(deferred));\n                    }\n                }\n            });\n            return true;\n        }\n    }\n\n    function isExitStatement(n) {\n        return n.type==='ReturnStatement' || n.type==='ThrowStatement'\n    }\n    /* Give unique names to TryCatch blocks */\n    function labelTryCatch(ast,engineMode) {\n        parser.treeWalker(ast, function (node, descend, path) {\n            if (node.type === 'TryStatement' && !node.$seh) {\n                if (!examine(path[0].parent).isBlockStatement) {\n                  path[0].parent[path[0].field] = {\n                    type:'BlockStatement',\n                    body:[node]\n                  } ;\n                }\n                // Every try-catch needs a name, so asyncDefine/asyncAwait knows who's handling errors\n                node.$seh = generateSymbol(\"Try\") + \"_\";\n                node.$containedAwait = !!containsAwait(node);\n                node.$finallyExit = node.finalizer && inAsync(path) && !!contains(node.finalizer.body,isExitStatement) ;\n\n                if (node.$containedAwait || node.$finallyExit) {\n                    node.$needsMapping = engineMode? !node.$finallyExit : true ;\n                    var parent = getExit(path, [opts]);\n                    if (node.finalizer && !node.handler) {\n                        // We have a finally, but no 'catch'. Create the default catch clause 'catch(_ex) { throw _ex }'\n                        var exSym = ident(generateSymbol(\"exception\"));\n                        node.handler = {\n                            \"type\": \"CatchClause\",\n                            \"param\": exSym,\n                            \"body\": {\n                                \"type\": \"BlockStatement\",\n                                \"body\": [{\n                                    \"type\": \"ThrowStatement\",\n                                    \"argument\": exSym\n                                }]\n                            }\n                        };\n                    }\n                    if (!node.handler && !node.finalizer) {\n                        var ex = new SyntaxError(where(node.value) + \"try requires catch and/or finally clause\", pr.filename, node.start);\n                        ex.pos = node.start;\n                        ex.loc = node.loc.start;\n                        throw ex;\n                    }\n                    if (node.finalizer) {\n                        setExit(node.block, {\n                            $error: node.$seh + \"Catch\",\n                            $return: deferredFinally(node, parent.$return)\n                        });\n                        setExit(node.handler, {\n                            $error: deferredFinally(node, parent.$error),\n                            $return: deferredFinally(node, parent.$return)\n                        });\n                    } else {\n                        setExit(node.block, {\n                            $error: node.$seh + \"Catch\",\n                            $return: parent.$return\n                        });\n                    }\n                }\n            }\n            descend();\n        });\n        return ast;\n    }\n\n    function afterDirectives(body,nodes) {\n        for (var i=0; i<body.length; i++) {\n            if (examine(body[i]).isDirective)\n                continue ;\n            body.splice.apply(body,[i,0].concat(nodes)) ;\n            return ;\n        }\n        body.splice.apply(body,[body.length,0].concat(nodes)) ;\n    }\n\n    function inAsync(path) {\n        for (var i=0; i<path.length; i++)\n            if (examine(path[i].self).isFunction)\n                return path[i].self.async || path[i].self.$wasAsync ;\n        return false ;\n    }\n\n    function mapTryCatch(node, path, down) {\n        if (node.$needsMapping) {\n            var continuation, ctnName, catchBody;\n            var ref = path[0];\n            if ('index' in ref) {\n                var i = ref.index + 1;\n                var afterTry = ref.parent[ref.field].splice(i, ref.parent[ref.field].length - i);\n                if (afterTry.length) {\n                    ctnName = node.$seh + \"Post\";\n                    var afterContinuation = down(makeBoundFn(ctnName, afterTry, [], getExit(path, [opts]).$error));\n                    ref.parent[ref.field].splice(ref.index,0,afterContinuation);\n                    continuation = parser.part(\"return $0()\",\n                        [node.finalizer ? deferredFinally(node, ident(ctnName)) : ident(ctnName)]).body[0] ;\n                } else if (node.finalizer) {\n                    continuation = returnThisCall(deferredFinally(node));\n                }\n            } else {\n                throw new Error(pr.filename + \" - malformed try/catch blocks\");\n            }\n            node.$mapped = true;\n            if (continuation) {\n                node.block.body.push(cloneNode(continuation));\n                node.handler.body.body.push(cloneNode(continuation));\n            }\n            var binding = getExit(path, [opts]);\n            if (node.handler) {\n                var symCatch = ident(node.$seh + \"Catch\");\n                catchBody = cloneNode(node.handler.body);\n                var catcher = makeBoundFn(symCatch.name, catchBody, [cloneNode(node.handler.param)], node.finalizer ? deferredFinally(node, binding.$error) : binding.$error);\n                node.handler.body.body = [{\n                    type: 'CallExpression',\n                    callee: symCatch,\n                    arguments: [cloneNode(node.handler.param)]\n                }];\n                ref.parent[ref.field].splice(ref.index,0,catcher) ;\n            }\n            if (node.finalizer) {\n                var finalParams = {\n                    exit:ident(node.$seh + \"Exit\"),\n                    value:ident(node.$seh + \"Value\"),\n                    body:cloneNode(node.finalizer.body),\n                } ;\n                var chainFinalize = parser.part(\n                    \"(function ($value) {                                      \"+\n                    \"       {$:body}                                           \"+\n                    \"       return $exit && ($exit.call(this, $value));        \"+\n                    \"   })\",finalParams).expr ;\n\n                var finalizer = {\n                    type: 'VariableDeclaration',\n                    kind: 'var',\n                    declarations: [{\n                        type: \"VariableDeclarator\",\n                        id: ident(node.$seh + \"Finally\"),\n                        init: bindAsync({\n                            type:'FunctionExpression',\n                            params:[finalParams.exit],\n                            id:null,\n                            body:{\n                                type:'BlockStatement',\n                                body:[{\n                                    type: 'ReturnStatement',\n                                    argument: bindAsync(chainFinalize,binding.$error)\n                                }]\n                            }\n                        })\n                    }]\n                } ;\n\n                afterDirectives(ref.parent[ref.field],[finalizer]);\n                var callFinally = parser.part(\"return $0()\",\n                    [node.finalizer ? deferredFinally(node, ident(ctnName)) : ident(ctnName)]).body[0] ;\n                catchBody.body[catchBody.length - 1] = callFinally;\n                node.block.body[node.block.body.length - 1] = callFinally;\n                delete node.finalizer;\n            }\n        }\n    }\n\n    function walkDown(ast, mappers, state) {\n        var walked = [];\n\n        function closedWalk(ast,state) {\n            return parser.treeWalker(ast, function (node, descend, path) {\n                function walkDownSubtree(node) {\n                    return closedWalk(node, path);\n                }\n\n                if (walked.indexOf(node) < 0) {\n                    walked.push(node) ;\n                    mappers.forEach(function (m) {\n                        m(node, path, walkDownSubtree);\n                    });\n                }\n                descend();\n                return;\n            }, state);\n        }\n\n        closedWalk(ast,state)\n        return ast ;\n    }\n\n    function asyncAwait(ast, inAsync, parentCatcher) {\n        parser.treeWalker(ast, function (node, descend, path) {\n            if (node.type == 'IfStatement') {\n                if (node.consequent.type != 'BlockStatement' && containsAwait(node.consequent))\n                    node.consequent = {\n                    type: 'BlockStatement',\n                    body: [node.consequent]\n                };\n                if (node.alternate && node.alternate.type != 'BlockStatement' && containsAwait(node.alternate))\n                    node.alternate = {\n                    type: 'BlockStatement',\n                    body: [node.alternate]\n                };\n            }\n            descend();\n            if (examine(node).isAwait) {\n                var loc = node.loc;\n                /* Warn if this await expression is not inside an async function, as the return\n                 * will depend on the Thenable implementation, and references to $return might\n                 * not resolve to anything */\n                inAsync = inAsync || path.some(function (ancestor) {\n                    return ancestor.self && ancestor.self.$wasAsync;\n                });\n                if (!inAsync || inAsync === \"warn\") {\n                    var errMsg = where(node) + \"'await' used inside non-async function. \";\n                    if (opts.promises)\n                        errMsg += \"'return' value Promise runtime-specific\";\n                     else\n                        errMsg += \"'return' value from await is synchronous\";\n                    logger(errMsg + \". See https://github.com/MatAtBread/nodent#differences-from-the-es7-specification\");\n                }\n                var parent = path[0].parent;\n                if (parent.type === 'LogicalExpression' && parent.right === node) {\n                    logger(where(node.argument) + \"'\" + printNode(parent) + \"' on right of \" + parent.operator + \" will always evaluate '\" + printNode(node.argument) + \"'\");\n                }\n                if (parent.type === 'ConditionalExpression' && parent.test !== node) {\n                    logger(where(node.argument) + \"'\" + printNode(parent) + \"' will always evaluate '\" + printNode(node.argument) + \"'\");\n                }\n                var result = ident(generateSymbol(\"await\"));\n                var expr = cloneNode(node.argument);\n                coerce(node, result);\n                // Find the statement containing this await expression (and it's parent)\n                var stmt, body;\n                for (var n = 1;n < path.length; n++) {\n                    if (body = examine(path[n].self).isBlockStatement) {\n                        stmt = path[n - 1];\n                        break;\n                    }\n                }\n                if (!stmt)\n                    throw new Error(where(node) + \"Illegal await not contained in a statement\");\n                var containingExits = getExit(path, [parentCatcher,opts]);\n                var i = stmt.index;\n                var callback, callBack = body.splice(i, body.length - i).slice(1);\n                var returner;\n                // If stmt is of the form 'return fn(result.name)', just replace it a\n                // reference to 'fn'.\n                if (stmt.self.type === 'ReturnStatement' && stmt.self.argument.type === 'CallExpression' && stmt.self.argument.arguments.length === 1 && stmt.self.argument.arguments[0].name === result.name) {\n                    returner = (callback = stmt.self.argument.callee);\n                // If stmt is only a reference to the result, suppress the result\n                // reference as it does nothing\n                } else if (!(stmt.self.type === 'Identifier' || stmt.self.name === result.name || stmt.self.type === 'ExpressionStatement' && stmt.self.expression.type === 'Identifier' && stmt.self.expression.name === result.name)) {\n                    callBack.unshift(stmt.self);\n                    callback = {\n                        type: 'FunctionExpression',\n                        params: [cloneNode(result)],\n                        body: asyncAwait({\n                            type: 'BlockStatement',\n                            body: cloneNode(callBack)\n                        }, inAsync, containingExits)\n                    };\n                } else {\n                    if (callBack.length)\n                        callback = {\n                        type: 'FunctionExpression',\n                        params: [cloneNode(result)],\n                        body: asyncAwait({\n                            type: 'BlockStatement',\n                            body: cloneNode(callBack)\n                        }, inAsync, containingExits)\n                    };\n                     else {\n                        callback = {\n                            type: 'FunctionExpression',\n                            params: [],\n                            body: {\n                                type: 'BlockStatement',\n                                body: []\n                            }\n                        };\n                    }\n                }\n                // Wrap the callback statement(s) in a Block and transform them\n                if (!returner) {\n                    if (callback) {\n                        returner = bindAsync(callback,containingExits.$error) ;\n                    } else {\n                        returner = {\n                            type: 'FunctionExpression',\n                            params: [],\n                            body: {\n                                type: 'BlockStatement',\n                                body: []\n                            }\n                        };\n                    }\n                }\n                if (opts.wrapAwait) {\n                    expr = {\n                        type: 'CallExpression',\n                        arguments: [expr],\n                        callee: (opts.promises || opts.generators)?{\n                            type: 'MemberExpression',\n                            object: ident('Promise'),\n                            property: ident('resolve')\n                        }:{\n                            // ES7 makeThenable\n                            type: 'MemberExpression',\n                            object: ident('Object'),\n                            property: ident('$makeThenable')\n                        }\n                    };\n                }\n                var exitCall = {\n                    type: 'CallExpression',\n                    callee: {\n                        type: 'MemberExpression',\n                        object: expr,\n                        property: ident('then', loc),\n                        computed: false\n                    },\n                    arguments: [returner,containingExits.$error]\n                };\n                body.push({\n                    loc: loc,\n                    type: 'ReturnStatement',\n                    argument: exitCall\n                });\n            }\n            return true;\n        });\n        return ast;\n    }\n\n    // Transform a for..in into it's iterative equivalent\n    function transformForIn(node, path) {\n        var label = node.$label ;\n        delete node.$label ;\n\n        var idx = ident(generateSymbol(\"idx\"))\n        var inArray = ident(generateSymbol(\"in\"));\n        var declVars = parser.part(\"var $0,$1 = [];for ($0 in $2) $1.push($0)\",[idx,inArray,node.right]).body ;\n        var loop = parser.part(\"for ($0; $1.length;){ $2 = $1.shift(); $:3 ; }\",[\n            node.left,\n            inArray,\n            node.left.type === 'VariableDeclaration' ? node.left.declarations[0].id : node.left,\n            node.body]).body[0] ;\n        loop.$label = label ;\n        for (var b=0; b<path.length; b++) {\n            if (examine(path[b].parent).isBlockStatement) {\n                path[b].parent[path[b].field].splice(path[b].index,0,declVars[0],declVars[1]) ;\n                break ;\n            }\n        }\n        coerce(node,loop) ;\n    }\n\n    // Transform a for..of into it's iterative equivalent\n    function iterizeForOf(node, path) {\n        if (node.body.type !== 'BlockStatement') {\n            node.body = {\n                type: 'BlockStatement',\n                body: [node.body]\n            };\n        }\n        var index, iterator, initIterator = parser.part(\"[$0[Symbol.iterator]()]\",[node.right]).expr;\n\n        if (node.left.type === 'VariableDeclaration') {\n            if (node.left.kind==='const')\n                node.left.kind = 'let' ;\n\n            index = node.left.declarations[0].id ;\n            var decls = getDeclNames(node.left.declarations[0].id) ;\n            iterator = ident(generateSymbol(\"iterator_\" + decls.join('_')));\n\n            node.left.declarations = decls.map(function(name){\n                return {\n                    type: \"VariableDeclarator\",\n                    id: ident(name)\n                } ;\n            }) ;\n            node.left.declarations.push({\n                type: \"VariableDeclarator\",\n                id: iterator,\n                init: initIterator\n            });\n            node.init = node.left;\n        } else {\n            index = node.left;\n            iterator = ident(generateSymbol(\"iterator_\" + index.name));\n            var declaration = {\n                type: 'VariableDeclaration',\n                kind: 'var',\n                declarations: [{\n                    type: \"VariableDeclarator\",\n                    id: iterator,\n                    init: initIterator\n                }]\n            };\n            node.init = declaration;\n        }\n        node.type = 'ForStatement';\n        node.test = parser.part(\"!($0[1] = $0[0].next()).done && (($1 = $0[1].value) || true)\",[iterator,index]).expr ;\n        delete node.left;\n        delete node.right;\n    }\n\n    /* Map loops */\n    /* As of v3.0.0 loops are asynchronized via a trampoline to prevent stack overflow in big loops with no actionable awaits. */\n    function mapLoops(node, path, down) {\n        var depth = node.$depth ;\n        if (node.type === 'ForInStatement' && containsAwait(node)) {\n          transformForIn(node, path) ;\n        } else if (node.type === 'ForOfStatement' && containsAwait(node)) {\n          iterizeForOf(node, path);\n        }\n\n        // Are we inside a loop that has already been asynchronized and is labelled?\n        var inAsyncLoop = path.some(function(p){\n            return ('$label' in p.self && p.self.type==='ForStatement' && p.self.$mapped) ;\n        }) ;\n\n        // Check if the loop contains an await, or a labelled exit if we're inside an async loop\n        function mappableLoop(n){\n            return (n.type==='AwaitExpression' && !n.$hidden)\n                || (inAsyncLoop && (n.type==='BreakStatement'|| n.type==='ContinueStatement') && n.label)\n        };\n\n        if (!node.$mapped && examine(node).isLoop && contains(node,mappableLoop)) {\n          path[0].self.$mapped = true ;\n          var p ;\n          var mapped = [] ;\n          var init = node.init;\n          var test = node.test || literal(true);\n          var step = node.update;\n          var body = node.body;\n\n          if (step) {\n            step = {\n              type:'ExpressionStatement',\n              expression: step\n            } ;\n          }\n\n          if (init) {\n            if (!examine(init).isStatement) {\n              init = {\n                type: 'ExpressionStatement',\n                expression: init\n              };\n            }\n            mapped.push(init) ;\n          }\n\n          var ref, label ;\n          if (node.$label) {\n            label = node.$label.name ;\n            ref = path[1] ;\n          } else {\n            label = generatedSymbol++ ;\n            ref = path[0] ;\n          }\n\n          label = opts.generatedSymbolPrefix + \"Loop_\" + label;\n          var idTrampoline = ident(label + \"_trampoline\") ;\n          var idIter = ident(label) ;\n          var idStep = step ? ident(label + \"_step\") : idIter ;\n          var idContinuation  = ident(label + \"_exit\") ;\n          var idBounce = ident(\"q\") ;\n          var idCatchParam = ident(\"$exception\") ;\n          var continuation, deferredCode ;\n\n          if ('index' in ref) {\n            var idx = ref.index;\n            deferredCode = ref.parent[ref.field].splice(idx + 1, ref.parent[ref.field].length - (idx + 1));\n          } else {\n            deferredCode = [] ;\n          }\n\n          continuation = makeContinuation(idContinuation, deferredCode) ;\n          var returnIter = {\n            \"type\": \"ReturnStatement\",\n            \"argument\": idIter\n          } ;\n\n          var returnStep = {\n              \"type\": \"ReturnStatement\",\n              \"argument\": idStep\n          } ;\n\n          var returnBreak = {\n              type: 'ReturnStatement',\n              argument: {\n                  \"type\": \"ArrayExpression\",\n                  \"elements\":[literal(1)]\n              }\n          };\n\n          parser.treeWalker(body, function mapExits(n, descend, subpath) {\n              if (examine(n).isFunction || examine(n).isLoop) {\n                  return true;\n              } else if (n.type === 'BreakStatement' || n.type === 'ContinueStatement') {\n                  if (n.label) {\n                      var labelStack = subpath.filter(function(p){\n                          return '$label' in p.self\n                      }).map(function(p,idx){\n                          return p.self.$label && p.self.$label.name\n                      }) ;\n\n                      // Work out how many loops to exit by examining subpath.\n                      var loops = [] ;\n                      for (var l=0; l<labelStack.length; l++) {\n                          if (labelStack[l] === n.label.name) {\n                              if (n.type === 'BreakStatement')\n                                  loops.push(literal(1)) ;\n                              subpath[0].replace({\n                                  type: 'ReturnStatement',\n                                  argument: {\n                                      \"type\": \"ArrayExpression\",\n                                      \"elements\":loops.reverse()\n                                  }\n                              }) ;\n                              break ;\n                          }\n                          loops.push(literal(0)) ;\n                      }\n                  } else {\n                      if (n.type === 'BreakStatement')\n                          subpath[0].replace(returnBreak) ;\n                      else // continue;\n                          subpath[0].replace(returnStep) ;\n                  }\n              } else {\n                descend();\n              }\n          },path) ;\n\n          if (body.type === 'BlockStatement')\n            body = body.body.slice(0) ;\n          else\n            body = [body] ;\n\n          if (node.type==='DoWhileStatement') {\n            body = body.concat({\n              \"type\": \"IfStatement\",\n              \"test\": {\n                type:'UnaryExpression',\n                argument:test,\n                prefix:true,\n                operator:'!'\n              },\n              \"consequent\": returnBreak,\n              alternate:returnStep\n            }) ;\n          } else {\n            body = [{\n              \"type\": \"IfStatement\",\n              \"test\": test,\n              \"consequent\": {\n                \"type\": \"BlockStatement\",\n                \"body\": body.concat(returnStep)\n              },\n              alternate:returnBreak\n            }] ;\n          }\n\n          if (opts.noRuntime) {\n              mapped.push({\n                  \"type\": \"VariableDeclaration\",\n                  \"declarations\": [{\n                    \"type\": \"VariableDeclarator\",\n                    \"id\": idTrampoline\n                  }],\n                  \"kind\": \"var\"\n                }) ;\n          }\n          var invokeIterate ;\n          var exit = getExit(path, [opts]).$error ;\n          if (opts.noRuntime) {\n            invokeIterate = parser.part(\n                opts.es6target?\n                    \"($idTrampoline = ((q) => { \"+\n                    \"    $$setMapped: while (q) { \"+\n                    \"         if (q.then)  \"+\n                    (depth===1?\n                    \"             return void q.then($idTrampoline, $exit); \":\n                    \"             return q.then($idTrampoline, $exit); \")+\n                    \"         try { \"+\n                    \"             if (q.pop)  \"+\n                    \"                 if (q.length)  \"+\n                    \"                 return q.pop() ? $idContinuation.call(this) : q; \"+\n                    \"              else  \"+\n                    \"                 q = $idStep; \"+\n                    \"              else  \"+\n                    \"                 q = q.call(this) \"+\n                    \"          } catch (_exception) { \"+\n                    \"             return $exit(_exception); \"+\n                    \"          } \"+\n                    \"     } \"+\n                    \"}))($idIter)\":\n                    \"($idTrampoline = (function (q) { \"+\n                    \"    $$setMapped: while (q) { \"+\n                    \"         if (q.then)  \"+\n                    (depth===1?\n                    \"             return void q.then($idTrampoline, $exit); \":\n                    \"             return q.then($idTrampoline, $exit); \")+\n                    \"         try { \"+\n                    \"             if (q.pop)  \"+\n                    \"                 if (q.length)  \"+\n                    \"                 return q.pop() ? $idContinuation.call(this) : q; \"+\n                    \"              else  \"+\n                    \"                 q = $idStep; \"+\n                    \"              else  \"+\n                    \"                 q = q.call(this) \"+\n                    \"          } catch (_exception) { \"+\n                    \"             return $exit(_exception); \"+\n                    \"          } \"+\n                    \"     } \"+\n                    \"}).bind(this))($idIter)\",\n                {\n                     setMapped:function(n){ n.$mapped = true ; return n },\n                     idTrampoline:idTrampoline,\n                     exit:exit,\n                     idIter:idIter,\n                     idContinuation:idContinuation,\n                     idStep:idStep\n                }).expr ;\n          } else {\n            invokeIterate = parser.part(\"(Function.$0.trampoline(this,$1,$2,$3,$5)($4))\",[\n                genIdent.asyncbind,\n                idContinuation,idStep,exit,\n                idIter,\n                literal(depth===1)\n            ]).expr;\n          }\n\n          mapped.push({type:'ReturnStatement',argument:invokeIterate}) ;\n          mapped.push({\n              $label:node.$label,\n              \"type\": \"FunctionDeclaration\",\n              \"id\": idIter,\n              \"params\": [],\n              \"body\": {\n                  \"type\": \"BlockStatement\",\n                  \"body\": body\n              }\n          }) ;\n\n          if (step) {\n              mapped.push({\n                  \"type\": \"FunctionDeclaration\",\n                  id: idStep,\n                  \"params\": [],\n                  \"body\": {\n                      \"type\": \"BlockStatement\",\n                      \"body\": [ step,returnIter ]\n                  }\n              }) ;\n          }\n\n          if (init && init.type==='VariableDeclaration' && (init.kind==='let' || init.kind==='const')) {\n              if (init.kind==='const')\n                  init.kind = 'let' ;\n\n              path[0].replace([{\n                  type:'BlockStatement',\n                  body:mapped.map(down)\n              },down(continuation)]) ;\n          } else {\n              mapped.push(continuation) ;\n              path[0].replace(mapped.map(down)) ;\n          }\n        }\n    }\n\n    /* Previous, recursive implementation for backwards compatibility */\n    function asyncLoops_1(ast,state) {\n        parser.treeWalker(ast, function (node, descend, path) {\n            function mapContinue(label) {\n                return {\n                    type: 'ReturnStatement',\n                    argument: {\n                        type: 'UnaryExpression',\n                        operator: 'void',\n                        prefix: true,\n                        argument: thisCall(label || symContinue)\n                    }\n                };\n            };\n            function mapExits(n, descend) {\n                if (n.type === 'BreakStatement') {\n                    coerce(n, cloneNode(mapBreak(n.label && opts.generatedSymbolPrefix + \"Loop_\" + n.label.name + \"_exit\")));\n                } else if (n.type === 'ContinueStatement') {\n                    coerce(n, cloneNode(mapContinue(n.label && opts.generatedSymbolPrefix + \"Loop_\" + n.label.name + \"_next\")));\n                } else if (examine(n).isFunction) {\n                    return true;\n                }\n                descend();\n            }\n\n            if (node.type === 'ForInStatement' && containsAwait(node)) {\n                transformForIn(node, path) ;\n            } else if (node.type === 'ForOfStatement' && containsAwait(node)) {\n                iterizeForOf(node, path);\n            }\n            descend();\n            var p;\n            if (examine(node).isLoop && containsAwait(node)) {\n                var init = node.init;\n                var condition = node.test || literal(true);\n                var step = node.update;\n                var body = node.body;\n                var loopUsesThis = containsThis(body) ;\n                if (init) {\n                    if (!examine(init).isStatement) {\n                        init = {\n                            type: 'ExpressionStatement',\n                            expression: init\n                        };\n                    }\n                }\n                step = step && {\n                    type: 'ExpressionStatement',\n                    expression: step\n                } ;\n                body = examine(body).isBlockStatement ? cloneNode(body).body : [cloneNode(body)];\n                var label = node.$label && node.$label.name ;\n                label = \"Loop_\" + (label || generatedSymbol++);\n                var symExit = opts.generatedSymbolPrefix + (label + \"_exit\");\n                var symContinue = opts.generatedSymbolPrefix + (label + \"_next\");\n                var loop = ident(opts.generatedSymbolPrefix + (label));\n                // How to exit the loop\n                var mapBreak = function (label) {\n                    return {\n                        type: 'ReturnStatement',\n                        argument: {\n                            type: 'UnaryExpression',\n                            operator: 'void',\n                            prefix: true,\n                            argument: {\n                                type: 'CallExpression',\n                                callee: ident(label || symExit),\n                                arguments: []\n                            }\n                        }\n                    };\n                };\n\n                // How to continue the loop\n                var defContinue = makeContinuation(symContinue, [{\n                    type: 'ReturnStatement',\n                    argument: {\n                        type: 'CallExpression',\n                        callee: loopUsesThis? bindAsync(loop):loop,\n                        arguments: [ident(symExit),genIdent.error]\n                    }\n                }]);\n                if (step)\n                    defContinue.body.body.unshift(step);\n                for (var i = 0;i < body.length; i++) {\n                    parser.treeWalker(body[i], mapExits);\n                }\n                body.push(cloneNode(mapContinue()));\n                var subCall = {\n                    type: 'FunctionExpression',\n                    id: loop,\n                    params: [ident(symExit),genIdent.error],\n                    body: {\n                        type: 'BlockStatement',\n                        body: [defContinue]\n                    }\n                };\n                if (node.type === 'DoWhileStatement') {\n                    defContinue.body.body = [{\n                        type: 'IfStatement',\n                        test: cloneNode(condition),\n                        consequent: {\n                            type: 'BlockStatement',\n                            body: cloneNode(defContinue.body.body)\n                        },\n                        alternate: {\n                            type: 'ReturnStatement',\n                            argument: {\n                                type: 'CallExpression',\n                                callee: ident(symExit),\n                                arguments: []\n                            }\n                        }\n                    }];\n                    subCall.body.body = [defContinue].concat(body);\n                } else {\n                    var nextTest = {\n                        type: 'IfStatement',\n                        test: cloneNode(condition),\n                        consequent: {\n                            type: 'BlockStatement',\n                            body: body\n                        },\n                        alternate: cloneNode(mapBreak())\n                    };\n                    subCall.body.body.push(nextTest);\n                }\n                var replace = {\n                    type: 'ExpressionStatement',\n                    expression: {\n                        type: 'AwaitExpression',\n                        argument: bindAsync(subCall, literal(0))\n                    }\n                };\n\n                if (init && init.type==='VariableDeclaration' && (init.kind==='let' || init.kind==='const')) {\n                    if (init.kind==='const')\n                        init.kind = 'let' ;\n                    replace = {\n                        type:'BlockStatement',\n                        body:[cloneNode(init),replace]\n                    };\n                    init = null ;\n                }\n\n                for (p = 0; p < path.length; p++) {\n                    var ref = path[p];\n                    if ('index' in ref) {\n                        if (init) {\n                            ref.parent[ref.field].splice(ref.index, 1, cloneNode(init), replace);\n                        } else {\n                            ref.parent[ref.field][ref.index] = replace;\n                        }\n                        return true;\n                    }\n                }\n            }\n            return true;\n        },state);\n        return ast;\n    }\n\n    function containsAsyncExit(fn) {\n        if (!examine(fn).isFunction) {\n            throw new Error(\"Cannot examine non-Function node types for async exits\") ;\n        }\n\n        return contains(fn.body,function(node){\n            return ((node.type === 'Identifier' && (node.name === opts.$return || node.name === opts.$error))\n                || (isExitStatement(node) && examine(node).isAsync)) ;\n        },function(node){\n            return !(examine(node).isFunction && (node.$wasAsync || examine(node).isAsync)) ;\n        }) ;\n    }\n\n    // TODO: Hoist directives (as in asyncDefine)\n    function asyncDefineMethod(ast) {\n        return parser.treeWalker(ast, function (node, descend, path) {\n            var transform = getMemberFunction(node);\n            descend();\n            if (!transform || !examine(transform).isAsync)\n                return;\n            if (node.kind == 'set') {\n                var ex = new SyntaxError(where(transform) + \"method 'async set' cannot be invoked\", pr.filename, node.start);\n                ex.pos = node.start;\n                ex.loc = node.loc.start;\n                throw ex;\n            }\n\n            transform.async = false;\n            var usesArgs = replaceArguments(transform);\n            if (!containsAsyncExit(transform) && (transform.body.body.length === 0 || transform.body.body[transform.body.body.length - 1].type !== 'ReturnStatement')) {\n                transform.body.body.push({\n                    type: 'ReturnStatement'\n                });\n            }\n            var funcback = bindAsync(setExit({\n                    type: 'FunctionExpression',\n                    params: [genIdent.return,genIdent.error],\n                    body: asyncDefineMethod(mapReturns(transform.body, path)),\n                    $wasAsync: true\n                }, opts),(opts.promises || opts.generators || opts.engine) ? null : literal(opts.lazyThenables?0:true) ) ;\n\n            if (opts.promises) {\n                transform.body = {\n                    type: 'BlockStatement',\n                    body: [{\n                        type: 'ReturnStatement',\n                        argument: {\n                            type: 'NewExpression',\n                            callee: ident('Promise'),\n                            arguments: [funcback]\n                        }\n                    }]\n                };\n            } else {\n                transform.body = {\n                    type: 'BlockStatement',\n                    body: [{\n                        type: 'ReturnStatement',\n                        argument: funcback\n                    }]\n                };\n            }\n            if (usesArgs) {\n                afterDirectives(transform.body.body,[assign$Args]);\n            }\n        });\n    }\n\n    function asyncDefine(ast) {\n        parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            if (examine(node).isAsync && examine(node).isFunction) {\n                var member ;\n                if ((member = getMemberFunction(path[0].parent))\n                    && examine(member).isAsync && path[0].parent.kind === 'get')  {\n                    warnAsyncGetter(path[0].parent.key) ;\n                }\n                delete node.async;\n                var fnBody;\n                var usesArgs = replaceArguments(node);\n                if (examine(node.body).isBlockStatement) {\n                    if (!containsAsyncExit(node) && (node.body.body.length === 0 || node.body.body[node.body.body.length - 1].type !== 'ReturnStatement')) {\n                        node.body.body.push({\n                            type: 'ReturnStatement'\n                        });\n                    }\n                    fnBody = {\n                        type: 'BlockStatement',\n                        body: node.body.body.map(function (sub) {\n                            return mapReturns(sub, path);\n                        })\n                    };\n                } else {\n                    fnBody = {\n                        type: 'BlockStatement',\n                        body: [mapReturns({\n                            type: 'ReturnStatement',\n                            argument: node.body\n                        }, path)]\n                    };\n                    node.expression = false;\n                }\n\n                fnBody = bindAsync(setExit({\n                        type: 'FunctionExpression',\n                        params: [genIdent.return,genIdent.error],\n                        body: fnBody,\n                        $wasAsync: true\n                    }, opts),(opts.promises || opts.generators || opts.engine) ? null : literal(opts.lazyThenables?0:true)) ;\n\n                if (opts.promises) {\n                    fnBody = {\n                        type: 'NewExpression',\n                        callee: ident('Promise'),\n                        arguments: [fnBody]\n                    };\n                }\n                fnBody = {\n                    type: 'BlockStatement',\n                    body: [{\n                        type: 'ReturnStatement',\n                        loc: node.loc,\n                        argument: fnBody\n                    }]\n                };\n                if (usesArgs)\n                    afterDirectives(fnBody.body,[assign$Args]);\n                node.body = fnBody;\n                return;\n            }\n        });\n        return ast;\n    }\n\n    /*\n     * Rewrite\n      async function <name>?<argumentlist><body>\n    to\n      function <name>?<argumentlist>{ return function*() {<body>}.$asyncspawn(); }\n     */\n    // Like mapReturns, but ONLY for return/throw async\n    function mapAsyncReturns(ast) {\n        if (Array.isArray(ast)) {\n            return ast.map(mapAsyncReturns);\n        }\n        var lambdaNesting = 0;\n        return parser.treeWalker(ast, function (node, descend, path) {\n            if ((node.type === 'ThrowStatement' || node.type === 'ReturnStatement') && !node.$mapped) {\n                if (lambdaNesting > 0) {\n                    if (examine(node).isAsync) {\n                        delete node.async;\n                        node.argument = {\n                            \"type\": \"CallExpression\",\n                            \"callee\": node.type === 'ThrowStatement' ? genIdent.error : genIdent.return,\n                            \"arguments\": node.argument ? [node.argument] : []\n                        };\n                        node.type = 'ReturnStatement';\n                        return;\n                    }\n                }\n            } else if (examine(node).isFunction) {\n                lambdaNesting++;\n                descend(node);\n                lambdaNesting--;\n                return;\n            }\n            descend(node);\n        });\n    }\n\n    function spawnBody(body, deferExit) {\n        if (opts.noRuntime)\n            throw new Error(\"Nodent: 'noRuntime' option only compatible with -promise and -engine modes\") ;\n\n        return parser.part(\"{ return (function*($return,$error){ $:body }).$asyncspawn(Promise,this) }\",{\n            'return':genIdent.return,\n            error:genIdent.error,\n            asyncspawn:genIdent.asyncspawn,\n              body: mapAsyncReturns(body).concat(deferExit ? [{\n                  type: 'ReturnStatement',\n                  argument: genIdent.return\n              }] : [])\n        }).body[0] ;\n    }\n\n    function warnAsyncGetter(id) {\n        if (!id.$asyncgetwarninig) {\n            id.$asyncgetwarninig = true;\n            logger(where(id) + \"'async get \"+printNode(id)+\"(){...}' is non-standard. See https://github.com/MatAtBread/nodent#differences-from-the-es7-specification\");\n        }\n    }\n\n    function asyncSpawn(ast,engine) {\n        function mapAwaits(ast,hide) {\n            parser.treeWalker(ast, function (node, descend, path) {\n                if (node !== ast && examine(node).isFunction)\n                    return;\n                if (examine(node).isAwait) {\n                    if (hide) {\n                        node.$hidden = true;\n                        descend();\n                    } else {\n                        delete node.operator;\n                        node.delegate = false;\n                        node.type = 'YieldExpression';\n                        descend();\n                    }\n                } else\n                    descend();\n            });\n        }\n\n        function promiseTransform(ast) {\n            var promises = opts.promises;\n            opts.promises = true;\n            asyncTransforms(ast, true);\n            opts.promises = promises;\n        }\n\n        function expandArrows(fn) {\n            if (fn.body.type !== 'BlockStatement') {\n                fn.body = {\n                    type: 'BlockStatement',\n                    body: [{\n                        type: 'ReturnStatement',\n                        argument: fn.body\n                    }]\n                };\n            }\n            return fn;\n        }\n\n        function warnAsyncExit(exit, fn) {\n            if (!fn.$asyncexitwarninig) {\n                fn.$asyncexitwarninig = true;\n                logger(where(exit) + \"'async \" + ({\n                    ReturnStatement: 'return',\n                    ThrowStatement: 'throw'\n                })[exit.type] + \"' not possible in \"+(engine?'engine':'generator')+\" mode. Using Promises for function at \" + where(fn));\n            }\n        }\n\n        parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            var fn, exit, usesArgs;\n            if (examine(node).isAsync && examine(node).isFunction) {\n                var member ;\n                if ((member = getMemberFunction(path[0].parent))\n                    && examine(member).isAsync && path[0].parent.kind === 'get')  {\n                    warnAsyncGetter(path[0].parent.key) ;\n                }\n                if (exit = containsAsyncExit(node)) {\n                    // Do the Promise transform\n                    warnAsyncExit(exit, node.body);\n                    promiseTransform(node);\n                } else if (!engine) {\n                    fn = node;\n                    delete fn.async;\n                    usesArgs = replaceArguments(fn);\n                    mapAwaits(fn,false);\n                    fn = expandArrows(fn);\n                    fn.body = spawnBody(fn.body.body, exit);\n                    if (usesArgs)\n                        afterDirectives(fn.body.body,[assign$Args]);\n                    if (fn.id && path[0].parent.type === 'ExpressionStatement') {\n                        fn.type = 'FunctionDeclaration';\n                        path[1].replace(fn);\n                    } else {\n                        path[0].replace(fn);\n                    }\n                } else if (path[0].parent.kind !== 'get')\n                    mapAwaits(node,true) ;\n            } else if ((fn = getMemberFunction(node)) && examine(fn).isAsync) {\n                if (exit = containsAsyncExit(fn)) {\n                    // Do the Promise transform\n                    warnAsyncExit(exit, fn);\n                    promiseTransform(node);\n                } else if (!engine || node.kind==='get') {\n                    if (engine) {\n                        promiseTransform(node) ;\n                    } else {\n                        node.async = false;\n                        usesArgs = replaceArguments(fn);\n                        mapAwaits(fn,false);\n                        coerce(fn, expandArrows(fn));\n                        fn.body = spawnBody(fn.body.body, exit);\n                    }\n                    if (usesArgs)\n                        afterDirectives(fn.body.body,[assign$Args]);\n                }\n            }\n        });\n\n        // Map (and warn) about any out-of-scope awaits that are being\n        // mapped using Promises.\n        var st = cloneNode(opts);\n        opts.engine = false;\n        opts.generators = false;\n        blockifyArrows(ast);\n        hoistDeclarations(ast);\n        labelTryCatch(ast,st.engine);\n        mapLogicalOp(ast);\n        mapCondOp(ast);\n        walkDown(ast, [mapTryCatch,mapLoops,mapIfStmt,mapSwitch,mapBlock]);\n        asyncAwait(ast, \"warn\");\n        opts.engine = st.engine;\n        opts.generators = st.generators;\n        return ast;\n    }\n\n    /* Find all nodes within this scope matching the specified function */\n    function scopedNodes(ast, matching, flat) {\n        var matches = [];\n        parser.treeWalker(ast, function (node, descend, path) {\n            if (node === ast)\n                return descend();\n            if (matching(node, path)) {\n                matches.push([].concat(path));\n                return;\n            }\n            if (flat || examine(node).isScope) {\n                return;\n            }\n            descend();\n        });\n        return matches;\n    }\n\n    function extractVars(vars,kind) {\n        var varDecls = [];\n        var duplicates = {} ;\n        vars = vars.filter(function(v){ return v[0].parent.type !== 'ExportNamedDeclaration'}) ;\n        if (vars.length) {\n            var definitions = {};\n            vars.forEach(function (path) {\n                function addName(name) {\n                    if (name in definitions) {\n                        duplicates[name] = self.declarations[i] ;\n                    } else {\n                        definitions[name] = self.declarations[i] ;\n                    }\n                }\n\n                var ref = path[0];\n                var self = ref.self;\n                var kind = self.kind ;\n                var values = [];\n                for (var i = 0;i < self.declarations.length; i++) {\n                    var decl = self.declarations[i] ;\n                    getDeclNames(decl.id).forEach(addName) ;\n                    if (decl.init) {\n                        var value = {\n                            type: 'AssignmentExpression',\n                            left: cloneNode(decl.id),\n                            operator: '=',\n                            right: cloneNode(decl.init)\n                        };\n                        values.push(value);\n                    }\n                }\n                if (values.length == 0)\n                    ref.remove();\n                else {\n                   var repl = (values.length > 1)?{type:'SequenceExpression',expressions:values} : values[0] ;\n                   if (ref.parent.type.slice(0,3)!=='For')\n                       repl = {type:'ExpressionStatement',expression:repl} ;\n                   ref.replace(repl);\n                }\n            });\n\n            var defs = Object.keys(definitions) ;\n            if (defs.length) {\n                defs = defs.map(function (name) {\n                    return {\n                        type: 'VariableDeclarator',\n                        id: ident(name),\n                        loc: definitions[name].loc,\n                        start: definitions[name].start,\n                        end: definitions[name].end\n                    };\n                });\n                if (!varDecls[0] || varDecls[0].type !== 'VariableDeclaration') {\n                    varDecls.unshift({\n                        type: 'VariableDeclaration',\n                        kind: kind,\n                        declarations: defs\n                    });\n                } else {\n                    varDecls[0].declarations = varDecls[0].declarations.concat(defs);\n                }\n            }\n        }\n        return { decls: varDecls, duplicates: duplicates } ;\n    }\n\n    function getDeclNames(id) {\n        if (!id) return [] ;\n        if (Array.isArray(id)) {\n            return id.reduce(function(z,j){ return z.concat(getDeclNames(j.id))},[]) ;\n        }\n        switch (id.type) {\n        case 'Identifier':\n            return [id.name]  ;\n        case 'AssignmentPattern':\n            return getDeclNames(id.left);\n        case 'ArrayPattern':\n            return id.elements.reduce(function(z,e){ return z.concat(getDeclNames(e)) },[]) ;\n        case 'ObjectPattern':\n            return id.properties.reduce(function(z,e){ return z.concat(getDeclNames(e)) },[]) ;\n        case 'ObjectProperty':\n        case 'Property':\n            return getDeclNames(id.value) ;\n        case 'RestElement':\n        case 'RestProperty':\n            return getDeclNames(id.argument) ;\n        }\n    }\n\n    function checkConstsNotAssigned(ast) {\n        /* Ensure no consts are on the LHS of an AssignmentExpression */\n        var names = {} ;\n\n        function fail(node){\n            logger(where(node) + \"Possible assignment to 'const \" + printNode(node)+\"'\");\n        }\n\n        function checkAssignable(target) {\n            switch (target.type) {\n            case 'Identifier':\n                // Find the declaration of any names on the left\n                if (names[target.name] === 'const') fail(target) ;\n                break ;\n            case 'ArrayPattern':\n                target.elements.forEach(function(e){\n                    if (names[e.name] === 'const') fail(e) ;\n                }) ;\n                break ;\n            case 'ObjectPattern':\n                target.properties.forEach(function(p){\n                    if (names[p.key.name] === 'const') fail(p) ;\n                }) ;\n                break ;\n            }\n        }\n\n        parser.treeWalker(ast, function (node, descend, path) {\n            var body = examine(node).isBlockStatement ;\n            if (body) {\n                names = Object.create(names) ;\n\n                for (var h=0; h<body.length; h++) {\n                    if (body[h].type === 'VariableDeclaration') {\n                        for (var i=0; i<body[h].declarations.length; i++) {\n                            getDeclNames(body[h].declarations[i].id).forEach(function(name){\n                                names[name] = body[h].kind ;\n                            }) ;\n                        }\n                    }\n                }\n            }\n            descend() ;\n\n            if (node.type === 'AssignmentExpression')\n                checkAssignable(node.left) ;\n            else if (node.type === 'UpdateExpression')\n                checkAssignable(node.argument) ;\n            if (body)\n                names = Object.getPrototypeOf(names) ;\n        });\n    }\n\n    /* Move directives, vars and named functions to the top of their scope iff. the scope contains an 'await' */\n    function hoistDeclarations(ast) {\n      var sequences = {\n        TemplateLiteral:function(x) { return x.expressions },\n        NewExpression:function(x) { return x.arguments },\n        CallExpression:function(x) { return x.arguments },\n        SequenceExpression:function(x) { return x.expressions },\n        ArrayExpression:function(x) { return x.elements },\n        ObjectExpression:function(oe){ return oe.properties.map(function(p){ return p.value })}\n      };\n        /* Identify SequenceExpressions, Parameter lists and VariableDeclarators that contain assigments and split them up\n        to ensure the correct evaluation order */\n\n        function containsAssign(ast){\n          return contains(ast, function(n){\n              return n.type==='AssignmentExpression'\n          });\n        }\n\n        parser.treeWalker(ast, function (node, descend, path) {\n          var i ;\n          descend() ;\n          // Ensure assigments are evaluated before any await expressions, eg:\n          // f(a=1, b = await a) --> a=1; f(a,b=await a)\n          \n          function moveAssignments(dest){\n              if (assignments.length) {\n                  dest.argument = {\n                      type:'SequenceExpression',\n                      expressions:assignments.map(function(a){\n                          var b = cloneNode(a)\n                          coerce(a,a.left);\n                          return b ;\n                      }).concat(dest.argument)\n                  } ;\n                  assignments = [] ;\n                }\n          }\n          \n          \n          if (node.type in sequences && !node.$hoisted) {\n            var expr = sequences[node.type](node) ;\n            var assignments = [] ;\n            var path ;\n            for (i=0; i<expr.length;i++) {\n              if (examine(expr[i]).isScope)\n                  continue ;\n              \n              if (path = containsAwait(expr[i]))\n                  moveAssignments(path[0].self) ;\n\n              if (!containsAwait(expr.slice(i+1)))\n                break ;\n\n              if (path = containsAssign(expr[i]))\n                assignments.push(path[0].self) ;\n            }\n          } else if (node.type === 'VariableDeclaration') {\n            // If any of the VariableDeclarators contain an initial value and are followed by a VariableDeclarator\n            // containing an await, split them up into multiple statements\n            for (i=node.declarations.length-1; i>0; i--) {\n              if (node.declarations[i] && node.declarations[i].init && containsAwait(node.declarations[i].init)) {\n                var insert = {\n                  type:'VariableDeclaration',\n                  kind: node.kind,\n                  declarations: node.declarations.splice(i)\n                } ;\n                var ref = path[0] ;\n                if ('index' in ref) {\n                  ref.parent[ref.field].splice(ref.index+1,0,insert) ;\n                } else throw new Error(\"VariableDeclaration not in a block\") ;\n              }\n            }\n          }\n        }) ;\n\n        /* Hoist declarations */\n        function isFreeVariable(kinds) {\n            return function(n, path) {\n                if (n.type === 'VariableDeclaration' && (n.kind = n.kind || 'var') && kinds.indexOf(n.kind)>=0) {\n                    var p = path[0] ;\n                    // Don't hoist the LHS of for (var/let/const _ of/in ... ; ;){}\n                    if (p.field == \"left\" && (p.parent.type === 'ForInStatement' || p.parent.type === 'ForOfStatement'))\n                        return false;\n\n                    // Don't hoist the LHS of for (let/const _ = ... ; ;){}\n                    if (p.field == \"init\" && p.parent.type === 'ForStatement' && (n.kind===\"const\" || n.kind===\"let\"))\n                        return false;\n\n                    return true;\n                }\n            }\n        }\n\n        function isHoistableFunction(n, path) {\n            // YES: We're a named function, but not a continuation\n            if (n.type==='FunctionDeclaration'  && n.id) {\n                return examine(n).isAsync || !n.$continuation;\n            }\n            // No, we're not a hoistable function\n            return false;\n        }\n\n        checkConstsNotAssigned(ast) ;\n\n        var inStrictBody = false ;\n        parser.treeWalker(ast, function (node, descend, path) {\n            var prevScope = inStrictBody ;\n            inStrictBody = inStrictBody || isStrict(node) ;\n\n            if (examine(node).isBlockStatement) {\n                if (containsAwait(node)) {\n                    // For this scope/block, find all the hoistable functions, vars and directives\n                    var isScope = !path[0].parent || examine(path[0].parent).isScope ;\n\n                    /* 'const' is highly problematic. In early version of Chrome (Node 0.10, 4.x, 5.x) non-standard behaviour:\n                     *\n                     * Node             scope           multiple-decls\n                     * v0.1x            function        SyntaxError\n                     * v0.1x strict     SyntaxError     SyntaxError\n                     * 4/5.x            function        SyntaxError\n                     * 4/5.x strict     block           ok (SyntaxError on duplicate in block)\n                     * 6.x  (as 4/5.x strict)\n                     *\n                     * To make these non-standard behaviours work, we treat a single declaration of a const identifier as requiring function scope (which works everywhere),\n                     * declare as a 'var' and initialize inline.\n                     * We treat multiple declarations as block-scoped, and let the engine work it out. To make consts blocked-scope, we use 'const' where possible (i.e. before\n                     * any await expressions), or declare as 'let' after an await. This breaks in non-strict mode in Node 4/5, as 'let' requires strict mode.\n                     *\n                     * In summary, what this means is:\n                     * - const's with a single declaration in the current scope (NOT block) should be hoisted to function level, and defined as 'var'\n                     * - const's with duplicate declarations in the current scope (NOT block) should be hoisted to block level, and defined as 'let'\n                     */\n\n                    var directives, consts, vars, lets, functions ;\n                    if (isScope) {\n                        consts = scopedNodes(node, isFreeVariable(['const']),false);\n                        var names = {}, duplicates = {} ;\n\n                        // Work out which const identifiers are duplicates\n                        // Ones that are only declared once can simply be treated as vars, whereas\n                        // identifiers that are declared multiple times have block-scope and are\n                        // only valid in node 6 or in strict mode on node 4/5\n                        consts.forEach(function(d){\n                            d[0].self.declarations.forEach(function(e){\n                                getDeclNames(e.id).forEach(function(n){\n                                    if (names[n] || duplicates[n]) {\n                                        delete names[n] ;\n                                        duplicates[n] = e ;\n                                    } else {\n                                        names[n] = e ;\n                                    }\n                                }) ;\n                            }) ;\n                        }) ;\n\n                        // Change all the declarations into assignments, since consts are always initialized\n                        consts.forEach(function(d){\n                            for (var depth=0; depth<d.length; depth++)\n                                if (examine(d[depth].parent).isBlockStatement)\n                                    break ;\n\n                            var ref = d[depth] ;\n                            ref.append({\n                                type: 'ExpressionStatement',\n                                expression: {\n                                    type: 'SequenceExpression',\n                                    expressions: d[0].self.declarations.map(function (d) {\n                                        var a = {\n                                            type: 'AssignmentExpression',\n                                            operator: '=',\n                                            left: d.id,\n                                            right: d.init\n                                        };\n                                        d.init = null ;\n                                        return a ;\n                                    })\n                                }\n                            });\n                            var ids = getDeclNames(d[0].self.declarations) ;\n                            var decls = ids.filter(function(name){ return name in duplicates }) ;\n                            if (decls.length) {\n                                d[0].append({\n                                    type:'VariableDeclaration',\n                                    kind:'let',\n                                    declarations: decls.map(function(name){\n                                        return {\n                                            type:'VariableDeclarator',\n                                            id:ident(name)\n                                        }\n                                    })\n                                }) ;\n                            }\n\n                            d[0].self.kind = 'var' ;\n                            decls = ids.filter(function(name){ return name in names }) ;\n                            if (decls.length) {\n                                d[0].self.declarations = decls.map(function(name){\n                                    return {\n                                        type:'VariableDeclarator',\n                                        id:ident(name)\n                                    }\n                                });\n                            } else {\n                              ref.remove() ;\n                            }\n                        }) ;\n                        vars = scopedNodes(node, isFreeVariable(['var']),false);\n                        lets = [] ;\n                    } else {\n                        lets = scopedNodes(node, isFreeVariable(['const']),true);\n                    }\n                    lets = lets.concat(scopedNodes(node, isFreeVariable(['let']),true));\n                    directives = scopedNodes(node, function (n) { return examine(n).isDirective },true);\n                    functions = scopedNodes(node, isHoistableFunction, inStrictBody);\n\n                    vars = vars?extractVars(vars,'var'):{duplicates:{},decls:[]} ;\n                    lets = lets?extractVars(lets,'let'):{duplicates:{},decls:[]} ;\n\n                    Object.keys(vars.duplicates).forEach(function(id){\n                        logger(where(vars.duplicates[id]) + \"Duplicate declaration '\" + printNode(vars.duplicates[id]) + \"'\");\n                    }) ;\n                    Object.keys(lets.duplicates).forEach(function(id){\n                        logger(where(lets.duplicates[id]) + \"Duplicate declaration '\" + printNode(lets.duplicates[id]) + \"'\");\n                    }) ;\n\n                    functions = functions.map(function (path) {\n                        var ref = path[0], symName;\n                        // What is the name of this function (could be async, so check the expression if necessary),\n                        // and should we remove and hoist, or reference and hoist?\n                        if (examine(ref.self).isAsync) {\n                            symName = ref.self.id.name;\n                            // If we're actually a top-level async FunctionExpression, redeclare as a FunctionDeclaration\n                            if (examine(ref.parent).isBlockStatement) {\n                                ref.self.type = 'FunctionDeclaration';\n                                ref.remove();\n                                return ref.self;\n                            }\n                            // We're an async FunctionExpression\n                            return ref.replace(ident(symName));\n                        }\n                        // We're just a vanilla FunctionDeclaration or FunctionExpression\n                        symName = ref.self.id.name;\n                        var movedFn = ref.self.type === 'FunctionDeclaration' ? ref.remove() : ref.replace(ident(symName));\n                        return movedFn;\n                    });\n\n                    directives = directives.map(function (path) {\n                        var ref = path[0];\n                        return ref.remove();\n                    });\n                    if (directives.length || vars.decls.length || lets.decls.length || functions.length) {\n                        node.body = directives.concat(vars.decls).concat(lets.decls).concat(functions).concat(node.body);\n                    }\n                }\n                inStrictBody = prevScope ;\n            }\n            descend();\n\n            // It makes life easier if labeled loops have the label to hand, so we simply reference them here with a hidden $label\n            // and keep a record of how nested the for loop is (since it's transformed top to bottom and counting during\n            // transformation is therefore not possible\n            if (node.type==='ForOfStatement' || node.type==='ForInStatement' || examine(node).isLoop) {\n                var depth = 0 ;\n                for (var n=0; n<path.length;n++)\n                    if (path[n].self.type==='ForOfStatement' || path[n].self.type==='ForInStatement' || examine(path[n].self).isLoop)\n                        depth += 1 ;\n                    else if (examine(path[n].self).isFunction)\n                        break ;\n\n                node.$depth = depth ;\n                if (path[0].parent.type==='LabeledStatement') {\n                    node.$label = path[0].parent.label ;\n                } else {\n                    node.$label = null ;\n                }\n            }\n            return true;\n        });\n        return ast;\n    }\n\n    function mapSupers(classNode, engine) {\n        function superID() {\n            return classNode.$superID = classNode.$superID || ident(\"$super$\" + generatedSymbol++);\n        }\n\n        return function (method) {\n            method = getMemberFunction(method);\n            if (method && examine(method).isAsync && (!engine || method.kind === 'get' || contains(method,function(n){\n              return (examine(n).isFunction && contains(n,function(n){\n                return n.type==='Super'\n              }) && contains(n,function(n){\n                return n.async && (n.type==='ReturnStatement' || n.type==='ThrowStatement') ;\n              }))\n            },true))) {\n                parser.treeWalker(method.body, function (node, descend, path) {\n                    var r;\n                    if (!examine(node).isClass) {\n                        descend();\n                        if (node.type === 'Super') {\n                            if (path[0].parent.type === 'MemberExpression') {\n                                if (path[1].parent.type === 'CallExpression' && path[1].field === 'callee') {\n                                    // super[m](...)  maps to:  this.$superid(m).call(this,...)\n                                    r = parser.part(\"this.$super($field).call(this,$args)\",{\n                                        'super':superID(),\n                                        field:path[0].parent.computed ? path[0].parent.property:literal(path[0].parent.property.name),\n                                        args:path[1].parent.arguments\n                                    }).expr ;\n                                    path[2].replace(r);\n                                } else {\n                                    // super[f],    maps to:  this.$superid(f)\n                                    r = parser.part(\"this.$super($field)\",{\n                                        'super':superID(),\n                                        field:path[0].parent.computed ?path[0].parent.property : literal(path[0].parent.property.name)\n                                    }).expr ;\n                                    path[1].replace(r);\n                                }\n                            } else {\n                                logger(where(node) + \"'super' in async methods must be deferenced. 'async constructor()'/'await super()' not valid.\");\n                            }\n                        }\n                    }\n                });\n            }\n        };\n    }\n\n    function fixSuperReferences(ast,engine) {\n        return parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            if (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {\n                node.body.body.forEach(mapSupers(node,engine));\n                if (node.$superID) {\n                    var method = parser.part(\"(function($field) { return super[$field] })\",{ field:ident(\"$field\") }).expr ;\n                    if (opts.babelTree) {\n                        method.type = 'ClassMethod';\n                        method.key = node.$superID;\n                        method.kind = 'method';\n                        node.body.body.push(method);\n                    } else {\n                        node.body.body.push({\n                            type: 'MethodDefinition',\n                            key: node.$superID,\n                            kind: 'method',\n                            value: method\n                        });\n                    }\n                }\n            }\n        });\n    }\n\n    function blockifyArrows(ast) {\n        parser.treeWalker(ast, function (node, descend, path) {\n            var awaiting = containsAwait(node);\n            if (awaiting)  {\n                if (node.type === 'ArrowFunctionExpression' && node.body.type !== 'BlockStatement') {\n                    node.body = {\n                        type: \"BlockStatement\",\n                        body: [{\n                            type: \"ReturnStatement\",\n                            argument: node.body\n                        }]\n                    };\n                }\n            }\n            descend();\n            return true;\n        });\n        return ast;\n    }\n\n    function exposeCompilerOpts(ast) {\n        // Expose compiler\n        parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            if (node.type === 'Identifier' && node.name === '__nodent') {\n                coerce(node, literal(opts));\n            }\n        });\n        return ast;\n    }\n\n    /* Called with a Program or FunctionDeclaration.body */\n    function isStrict(node) {\n        if (node.type === 'Program' && node.sourceType === 'module')\n            return true ;\n\n        var nodes ;\n        if (node.type === 'Program')\n            nodes = node.body ;\n        else if (examine(node).isFunction)\n            nodes = node.body.body ;\n        else return false ;\n\n        if (nodes) for (var i=0; i<nodes.length; i++)\n            if (examine(nodes[i]).isDirective && nodes[i].expression.value.match(/^\\s*use\\s+strict\\s*$/))\n                return true ;\n        return false ;\n    }\n\n    function containsBlockScopedDeclarations(nodes) {\n        for (var i = 0;i < nodes.length; i++) {\n            var node = nodes[i];\n            if (node.type === 'ClassDeclaration' ||\n                (node.type === 'VariableDeclaration' && (node.kind === 'let' || node.kind === 'const')) ||\n                (node.type === 'FunctionDeclaration' && node.id && node.id.name && !node.$continuation)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /* Remove un-necessary nested blocks and crunch down empty function implementations */\n    function cleanCode(ast) {\n        // Coalese BlockStatements\n        parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            if (node.type==='ArrowFunctionExpression'\n                && node.body.type === 'BlockStatement'\n                && node.body.body.length===1\n                && node.body.body[0].type==='ReturnStatement') {\n                node.body = node.body.body[0].argument\n            } else {\n                var block, child;\n                // If this node is a block with vanilla BlockStatements (no controlling entity), merge them\n                if (block = examine(node).isBlockStatement) {\n                    // Remove any empty statements from within the block\n                    // For ES6, this needs more care, as blocks containing 'let/const/class' have a scope of their own\n                    for (var i = 0;i < block.length; i++) {\n                        if ((child = examine(block[i]).isBlockStatement) && !containsBlockScopedDeclarations(child)) {\n                            if (!containsBlockScopedDeclarations(block[i]))\n                                [].splice.apply(block, [i,1].concat(child));\n                        }\n                    }\n                }\n            }\n        });\n        // Truncate BlockStatements with a Jump (break;continue;return;throw) inside\n        parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            if (examine(node).isJump) {\n                var ref = path[0];\n                if ('index' in ref) {\n                    var i = ref.index + 1;\n                    var ctn = ref.parent[ref.field];\n                    while (i < ctn.length) {\n                        // Remove any statements EXCEPT for function/var definitions\n                        if (ctn[i].type === 'VariableDeclaration' || examine(ctn[i]).isFunction && ctn[i].id)\n                            i += 1;\n                         else\n                            ctn.splice(i, 1);\n                    }\n                }\n            }\n        });\n        /* Inline continuations that are only referenced once */\n        // Find any continuations that have a single reference\n        parser.treeWalker(ast, function (node, descend, path) {\n            descend();\n            if (node.$thisCall && continuations[node.name]) {\n                if (continuations[node.name].ref) {\n                    delete continuations[node.name]; //   Multiple ref\n                } else {\n                    continuations[node.name].ref = node.$thisCall;\n                }\n            }\n        });\n        var calls = Object.keys(continuations).map(function (c) {\n            return continuations[c].ref;\n        });\n        if (calls.length) {\n            // Replace all the calls to the continuation with the body from the continuation followed by 'return;'\n            parser.treeWalker(ast, function (node, descend, path) {\n                descend();\n                if (calls.indexOf(node) >= 0) {\n                    if (path[1].self.type === 'ReturnStatement') {\n                        var sym = node.$thisCallName;\n                        var repl = cloneNode(continuations[sym].def.body.body);\n                        continuations[sym].$inlined = true;\n                        if (!examine(path[1].self).isJump)\n                            repl.push({\n                            type: 'ReturnStatement'\n                        });\n                        path[1].replace(repl);\n                    }\n                }\n            });\n            var defs = Object.keys(continuations).map(function (c) {\n                return continuations[c].$inlined && continuations[c].def;\n            });\n            // Remove all the (now inline) declarations of the continuations\n            parser.treeWalker(ast, function (node, descend, path) {\n                descend();\n                if (defs.indexOf(node) >= 0) {\n                    path[0].remove();\n                }\n            });\n        }\n\n        // Hoist generated FunctionDeclarations within ES5 Strict functions (actually put them at the\n        // end of the scope-block, don't hoist them, it's just an expensive operation)\n        var looksLikeES6 = (ast.type==='Program' && ast.sourceType==='module') || contains(ast,function(n){\n            return examine(n).isES6 ;\n        },true) ;\n\n        if (!looksLikeES6) {\n            var useStrict = isStrict(ast) ;\n            (function(ast){\n                parser.treeWalker(ast, function (node, descend, path) {\n                    if (node.type==='Program' || node.type==='FunctionDeclaration' || node.type==='FunctionExpression') {\n                        var wasStrict = useStrict ;\n                        useStrict = useStrict || isStrict(node) ;\n                        if (useStrict) {\n                            descend();\n\n                            var functionScope = node.type === 'Program' ? node : node.body ;\n                            var functions = scopedNodes(functionScope,function(n,path){\n                                if (n.type==='FunctionDeclaration') {\n                                    return path[0].parent !== functionScope ;\n                                }\n                            }) ;\n\n                            functions = functions.map(function (path) {\n                                return path[0].remove() ;\n                            });\n                            [].push.apply(functionScope.body,functions) ;\n                        } else {\n                            descend();\n                        }\n                        useStrict = wasStrict ;\n                    } else {\n                        descend();\n                    }\n                }) ;\n            })(ast);\n        }\n\n        /*\n        function replaceSymbols(ast,from,to) {\n            parser.treeWalker(ast,function(node,descend,path){\n                descend() ;\n                if (node.type=='Identifier' && node.name==from) {\n                    node.name = to ;\n                }\n            }) ;\n            return ast ;\n        }\n\n        // Find declarations of functions of the form:\n        //     function [sym]() { return _call_.call(this) }\n        // or\n        //     function [sym]() { return _call_() }\n        // and replace with:\n        //    _call_\n        // If the [sym] exists and is referenced elsewhere, replace those too. This\n        // needs to be done recursively from the bottom of the tree upwards.\n        // NB: If _call_ is in the parameter list for the function, this is NOT a correct optimization\n\n\n        // The symbol folding above might generate lines like:\n        //    $return.$asyncbind(this,$error)\n        // these can be simplified to:\n        //    $return\n        */\n\n        // Remove all the 'hiiden' node info generated during transformation\n        parser.treeWalker(ast,function(node,descend,path){\n            descend() ;\n            Object.keys(node).filter(function(k){ return k[0]==='$'}).forEach(function(k){\n                delete node[k] ;\n            }) ;\n        }) ;\n        return ast;\n    }\n}\n\nmodule.exports = {\n    printNode:printNode,\n    babelLiteralNode: babelLiteralNode,\n    asynchronize: function (pr, __sourceMapping, opts, logger) {\n        try {\n            return asynchronize(pr, __sourceMapping, opts, logger);\n        } catch (ex) {\n            if (ex instanceof SyntaxError) {\n                var l = pr.origCode.substr(ex.pos - ex.loc.column);\n                l = l.split(\"\\n\")[0];\n                ex.message += \" (nodent)\\n\" + l + \"\\n\" + l.replace(/[\\S ]/g, \"-\").substring(0, ex.loc.column) + \"^\";\n                ex.stack = \"\";\n            }\n            throw ex;\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent-runtime/runtime.js":"\"use strict\";\n/*\n * $asyncbind has multiple uses, depending on the parameter list. It is in Function.prototype, so 'this' is always a function\n *\n * 1) If called with a single argument (this), it is used when defining an async function to ensure when\n *      it is invoked, the correct 'this' is present, just like \"bind\". For legacy reasons, 'this' is given\n *      a memeber 'then' which refers to itself.\n * 2) If called with a second parameter (\"catcher\") and catcher!==true it is being used to invoke an async\n *      function where the second parameter is the error callback (for sync exceptions and to be passed to\n *      nested async calls)\n * 3) If called with the second parameter===true, it is the same use as (1), but the function is wrapped\n *      in an 'Promise' as well bound to 'this'.\n *      It is the same as calling 'new Promise(this)', where 'this' is the function being bound/wrapped\n * 4) If called with the second parameter===0, it is the same use as (1), but the function is wrapped\n *      in a 'LazyThenable', which executes lazily and can resolve synchronously.\n *      It is the same as calling 'new LazyThenable(this)' (if such a type were exposed), where 'this' is\n *      the function being bound/wrapped\n */\n\nfunction processIncludes(includes,input) {\n    var src = input.toString() ;\n    var t = \"return \"+src ;\n    var args = src.match(/.*\\(([^)]*)\\)/)[1] ;\n    var re = /['\"]!!!([^'\"]*)['\"]/g ;\n    var m = [] ;\n    while (1) {\n        var mx = re.exec(t) ;\n        if (mx)\n            m.push(mx) ;\n        else break ;\n    }\n    m.reverse().forEach(function(e){\n        t = t.slice(0,e.index)+includes[e[1]]+t.substr(e.index+e[0].length) ;\n    }) ;\n    t = t.replace(/\\/\\*[^*]*\\*\\//g,' ').replace(/\\s+/g,' ') ;\n    return new Function(args,t)() ;\n}\n\nvar $asyncbind = processIncludes({\n    zousan:require('./zousan').toString(),\n    thenable:require('./thenableFactory').toString()\n},\nfunction $asyncbind(self,catcher) {\n    \"use strict\";\n    if (!Function.prototype.$asyncbind) {\n        Object.defineProperty(Function.prototype,\"$asyncbind\",{value:$asyncbind,enumerable:false,configurable:true,writable:true}) ;\n    }\n\n    if (!$asyncbind.trampoline) {\n      $asyncbind.trampoline = function trampoline(t,x,s,e,u){\n        return function b(q) {\n                while (q) {\n                    if (q.then) {\n                        q = q.then(b, e) ;\n                        return u?undefined:q;\n                    }\n                    try {\n                        if (q.pop) {\n                            if (q.length)\n                              return q.pop() ? x.call(t) : q;\n                            q = s;\n                         } else\n                            q = q.call(t)\n                    } catch (r) {\n                        return e(r);\n                    }\n                }\n            }\n        };\n    }\n    if (!$asyncbind.LazyThenable) {\n        $asyncbind.LazyThenable = '!!!thenable'();\n        $asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = '!!!zousan')();\n    }\n\n    var resolver = this;\n    switch (catcher) {\n    case true:\n        return new ($asyncbind.Thenable)(boundThen);\n    case 0:\n        return new ($asyncbind.LazyThenable)(boundThen);\n    case undefined:\n        /* For runtime compatibility with Nodent v2.x, provide a thenable */\n        boundThen.then = boundThen ;\n        return boundThen ;\n    default:\n        return function(){\n            try {\n                return resolver.apply(self,arguments);\n            } catch(ex) {\n                return catcher(ex);\n            }\n        }\n    }\n    function boundThen() {\n        return resolver.apply(self,arguments);\n    }\n}) ;\n\nfunction $asyncspawn(promiseProvider,self) {\n    if (!Function.prototype.$asyncspawn) {\n        Object.defineProperty(Function.prototype,\"$asyncspawn\",{value:$asyncspawn,enumerable:false,configurable:true,writable:true}) ;\n    }\n    if (!(this instanceof Function)) return ;\n\n    var genF = this ;\n    return new promiseProvider(function enough(resolve, reject) {\n        var gen = genF.call(self, resolve, reject);\n        function step(fn,arg) {\n            var next;\n            try {\n                next = fn.call(gen,arg);\n                if(next.done) {\n                    if (next.value !== resolve) {\n                        if (next.value && next.value===next.value.then)\n                            return next.value(resolve,reject) ;\n                        resolve && resolve(next.value);\n                        resolve = null ;\n                    }\n                    return;\n                }\n\n                if (next.value.then) {\n                    next.value.then(function(v) {\n                        step(gen.next,v);\n                    }, function(e) {\n                        step(gen.throw,e);\n                    });\n                } else {\n                    step(gen.next,next.value);\n                }\n            } catch(e) {\n                reject && reject(e);\n                reject = null ;\n                return;\n            }\n        }\n        step(gen.next);\n    });\n}\n\n// Initialize async bindings\n$asyncbind() ;\n$asyncspawn() ;\n\n// Export async bindings\nmodule.exports = {\n    $asyncbind:$asyncbind,\n    $asyncspawn:$asyncspawn\n};\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent-runtime/zousan.js":"/* This code is based on:\nzousan - A Lightning Fast, Yet Very Small Promise A+ Compliant Implementation\nhttps://github.com/bluejava/zousan\nAuthor: Glenn Crownover <glenn@bluejava.com> (http://www.bluejava.com)\nVersion 2.3.3\nLicense: MIT */\n\"use strict\";\nmodule.exports = function(tick){\n    tick = tick || (typeof process===\"object\" && process.nextTick) || (typeof setImmediate===\"function\" && setImmediate) || function(f){setTimeout(f,0)};\n    var soon = (function () {\n        var fq = [], fqStart = 0, bufferSize = 1024;\n        function callQueue() {\n            while (fq.length - fqStart) {\n                try { fq[fqStart]() } catch(ex) { /* console.error(ex) */ }\n                fq[fqStart++] = undefined;\n                if (fqStart === bufferSize) {\n                    fq.splice(0, bufferSize);\n                    fqStart = 0;\n                }\n            }\n        }\n\n        return function (fn) {\n            fq.push(fn);\n            if (fq.length - fqStart === 1)\n                tick(callQueue);\n        };\n    })();\n\n    function Zousan(func) {\n        if (func) {\n            var me = this;\n            func(function (arg) {\n                me.resolve(arg);\n            }, function (arg) {\n                me.reject(arg);\n            });\n        }\n    }\n\n    Zousan.prototype = {\n        resolve: function (value) {\n            if (this.state !== undefined)\n                return;\n            if (value === this)\n                return this.reject(new TypeError(\"Attempt to resolve promise with self\"));\n            var me = this;\n            if (value && (typeof value === \"function\" || typeof value === \"object\")) {\n                try {\n                    var first = 0;\n                    var then = value.then;\n                    if (typeof then === \"function\") {\n                        then.call(value, function (ra) {\n                            if (!first++) {\n                                me.resolve(ra);\n                            }\n                        }, function (rr) {\n                            if (!first++) {\n                                me.reject(rr);\n                            }\n                        });\n                        return;\n                    }\n                } catch (e) {\n                    if (!first)\n                        this.reject(e);\n                    return;\n                }\n            }\n            this.state = STATE_FULFILLED;\n            this.v = value;\n            if (me.c)\n                soon(function () {\n                    for (var n = 0, l = me.c.length;n < l; n++)\n                        STATE_FULFILLED(me.c[n], value);\n                });\n        },\n        reject: function (reason) {\n            if (this.state !== undefined)\n                return;\n            this.state = STATE_REJECTED;\n            this.v = reason;\n            var clients = this.c;\n            if (clients)\n                soon(function () {\n                    for (var n = 0, l = clients.length;n < l; n++)\n                        STATE_REJECTED(clients[n], reason);\n                });\n        },\n        then: function (onF, onR) {\n            var p = new Zousan();\n            var client = {\n                y: onF,\n                n: onR,\n                p: p\n            };\n            if (this.state === undefined) {\n                if (this.c)\n                    this.c.push(client);\n                else\n                    this.c = [client];\n            } else {\n                var s = this.state, a = this.v;\n                soon(function () {\n                    s(client, a);\n                });\n            }\n            return p;\n        }\n    };\n\n    function STATE_FULFILLED(c, arg) {\n        if (typeof c.y === \"function\") {\n            try {\n                var yret = c.y.call(undefined, arg);\n                c.p.resolve(yret);\n            } catch (err) {\n                c.p.reject(err);\n            }\n        } else\n            c.p.resolve(arg);\n    }\n\n    function STATE_REJECTED(c, reason) {\n        if (typeof c.n === \"function\") {\n            try {\n                var yret = c.n.call(undefined, reason);\n                c.p.resolve(yret);\n            } catch (err) {\n                c.p.reject(err);\n            }\n        } else\n            c.p.reject(reason);\n    }\n\n    Zousan.resolve = function (val) {\n        if (val && (val instanceof Zousan))\n            return val ;\n        var z = new Zousan();\n        z.resolve(val);\n        return z;\n    };\n    Zousan.reject = function (err) {\n        if (err && (err instanceof Zousan))\n            return err ;\n        var z = new Zousan();\n        z.reject(err);\n        return z;\n    };\n\n    Zousan.version = \"2.3.3-nodent\" ;\n    return Zousan ;\n};\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent-runtime/thenableFactory.js":"module.exports = function() {\n    function isThenable(obj) {\n        return obj && (obj instanceof Object) && typeof obj.then===\"function\";\n    }\n\n    function resolution(p,r,how) {\n        try {\n            /* 2.2.7.1 */\n            var x = how ? how(r):r ;\n\n            if (p===x) /* 2.3.1 */\n                return p.reject(new TypeError(\"Promise resolution loop\")) ;\n\n            if (isThenable(x)) {\n                /* 2.3.3 */\n                x.then(function(y){\n                    resolution(p,y);\n                },function(e){\n                    p.reject(e)\n                }) ;\n            } else {\n                p.resolve(x) ;\n            }\n        } catch (ex) {\n            /* 2.2.7.2 */\n            p.reject(ex) ;\n        }\n    }\n\n    function Chained() {};\n    Chained.prototype = {\n        resolve:_unchained,\n        reject:_unchained,\n        then:thenChain\n    };\n    function _unchained(v){}\n    function thenChain(res,rej){\n        this.resolve = res;\n        this.reject = rej;\n    }\n    \n    function then(res,rej){\n        var chain = new Chained() ;\n        try {\n            this._resolver(function(value) {\n                return isThenable(value) ? value.then(res,rej) : resolution(chain,value,res);\n            },function(ex) {\n                resolution(chain,ex,rej) ;\n            }) ;\n        } catch (ex) {\n            resolution(chain,ex,rej);\n        }\n        return chain ;\n    }\n\n    function Thenable(resolver) {\n        this._resolver = resolver ;\n        this.then = then ;\n    };\n\n    Thenable.resolve = function(v){\n        return Thenable.isThenable(v) ? v : {then:function(resolve){return resolve(v)}};\n    };\n\n    Thenable.isThenable = isThenable ;\n\n    return Thenable ;\n} ;\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/covers/asyncfunction.js":"function Nothing(){}\n\nmodule.exports = function(nodent,config) {\n    config = config || {} ;\n    if (!('promises' in config))\n        config.promises = 'Promise' in global ;\n    if (!('log' in config) || config.log===false)\n        config.log = Nothing ;\n            \n    function AsyncFunction() {\n        var params = [].slice.call(arguments,0,-1) ;\n        var source = \"async function anonymous_AsyncFunction(\"+params.join(\",\")+\") {\\n\"+arguments[arguments.length-1]+\"\\n}\" ;\n        var pr = nodent.compile(source,\"(new AsyncFunction)\",undefined,config) ;\n        pr.ast = pr.ast.body[0].body ;\n        var asyncBody = nodent.prettyPrint(pr,config).code ;\n        params.push(asyncBody.slice(2,-2)) ;\n        var fn = Function.apply(this,params) ;\n        fn.__proto__ = AsyncFunction.prototype ;\n        Object.defineProperty(fn,\"source\",{value:source}) ;\n        fn.constructor = AsyncFunction ;\n        return fn ;\n    }\n    \n    AsyncFunction.prototype = Object.create(Function.prototype,{\n        toString:{\n            value:function(){\n                return this.source ;\n            }\n        },\n        toES5String:{\n            value:function(){\n                return Function.toString.apply(this) ;\n            }\n        },\n    }) ;\n    \n    return AsyncFunction ;\n}\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/covers/events.js":"module.exports = function(nodent,opts) {\n    if (!opts) opts = {} ;\n    if (!opts.Promise)\n        opts.Promise = global.Promise || nodent.Thenable ;\n\n\tvar events = require('events');\n\tif (!events.EventEmitter.prototype.wait) {\n\t\tevents.EventEmitter.prototype.wait = function(event) {\n\t\t\tvar ee = this ;\n\t\t\treturn new (opts.Promise)(function($return,$error) {\n\t\t\t\tee.once(event,$return) ;\n\t\t\t\tee.once('error',$error) ;\n\t\t\t}) ;\n\t\t};\n\t}\n\treturn events;\n};\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/covers/http.js":"/**\n * Create an instance of noDent friendly http with the API:\n * \t\tres = await nodent.http.get(opts) ;\n * \t\t\t... set up some stuff with res...\n * \t\tawait res.wait('end') ;\n */\n\nmodule.exports = function(nodent,config) {\n\tnodent.require('events') ;\n\tvar protos = {http:require('http')} ;\n\tvar cover = Object.create(protos.http) ;\n\tvar protocol ;\n\t\n    if (!config) config = {} ;\n    if (!config.Promise)\n        config.Promise = global.Promise || nodent.Thenable ;\n\n\tif (config.autoProtocol) {\n\t\tprotos.https = require('https') ;\n\t\tprotocol = function(opts){\n\t\t\tvar p ;\n\t\t\tif (typeof opts===\"string\") {\n\t\t\t\tp = opts.split(\":\")[0] ;\n\t\t\t} else if (typeof opts===\"object\") {\n\t\t\t\tp = opts.protocol.replace(/:?$/,\"\") ;\n\t\t\t} \n\t\t\tif (p && protos[p]) return protos[p] ;\n\t\t\tthrow new Error(\"Protocol is not http or https\") ;\n\t\t}\n\t} else {\n\t\tprotocol = function(){return protos.http;} ; \n\t}\n\n\tcover.request = function(opts){\n\t\treturn new (opts.Promise)(function($return,$error){\n\t\t\tvar request = protocol(opts).request(opts,function(){}) ;\n\t\t\trequest.on('error',$error) ;\n\t\t\t$return(request) ;\n\t\t}) ;\n\t};\n\n\tcover.get = function(opts){\n\t\treturn new (config.Promise)(function($return,$error){\n\t\t\tprotocol(opts).get(opts,$return).on('error',$error) ;\n\t\t}) ;\n\t};\n\n\tcover.getBody = function(opts){\n\t\treturn new (config.Promise)(function($return,$error){\n\t\t\tprotocol(opts).get(opts,function(res){\n\t\t\t\ttry {\n\t\t\t\t\tvar enc = \"utf8\" ;\n\t\t\t\t\tif (res.headers['content-type']) {\n\t\t\t\t\t\tvar m = res.headers['content-type'].match(/.*charset=(.*)\\b/) ;\n\t\t\t\t\t\tif (m && m.length>1)\n\t\t\t\t\t\t\tenc = m[1] ;\n\t\t\t\t\t}\n\t\t\t\t\tvar body = \"\" ;\n\t\t\t\t\tfunction handle(s) {\n\t\t\t\t\t\ts.on('error',$error) ;\n\t\t\t\t\t\ts.on('data', function (chunk) { \n\t\t\t\t\t\t\tbody += chunk ; \n\t\t\t\t\t\t});\n\t\t\t\t\t\ts.on('end',function(){\n\t\t\t\t\t\t\tif (res.statusCode==200)\n\t\t\t\t\t\t\t\t$return(body) ;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tvar err = new Error(\"HTTP error \"+res.statusCode) ;\n\t\t\t\t\t\t\t\terr.body = body ;\n\t\t\t\t\t\t\t\terr.res = res ;\n\t\t\t\t\t\t\t\t$error(err) ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) ;\n\t\t\t\t\t\treturn s ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tswitch (res.headers['content-encoding']) {\n\t\t\t\t\t// or, just use zlib.createUnzip() to handle both cases\n\t\t\t\t\tcase 'gzip':\n\t\t\t\t\tcase 'deflate':\n\t\t\t\t\t\tvar z = require('zlib').createUnzip() ;\n\t\t\t\t\t\thandle(z);\n\t\t\t\t\t\tres.pipe(z);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tres.setEncoding(enc);\n\t\t\t\t\t\thandle(res) ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} catch(ex) {\n\t\t\t\t\t$error(ex) ;\n\t\t\t\t}\n\t\t\t}).on('error',$error) ;\n\t\t}) ;\n\t};\n\treturn cover ;\n};\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/covers/https.js":"module.exports = function(nodent,config) {\n\tnodent.require('events') ;\n\n    if (!config) config = {} ;\n    if (!config.Promise)\n        config.Promise = global.Promise || nodent.Thenable ;\n    \n    var http = require('https') ;\n\tvar cover = Object.create(http) ;\n\n\tcover.request = function(opts){\n\t\treturn new (config.Promise)(function($return,$error){\n\t\t\tvar request = http.request(opts,function(){}) ;\n\t\t\trequest.on('error',$error) ;\n\t\t\t$return(request) ;\n\t\t}) ;\n\t};\n\t\n\tcover.get = function(opts){\n\t\treturn new (config.Promise)(function($return,$error){\n\t\t\thttp.get(opts,$return).on('error',$error) ;\n\t\t}) ;\n\t};\n\t\n\tcover.getBody = function(opts){\n\t\treturn new (config.Promise)(function($return,$error){\n\t\t\thttp.get(opts,function(res){\n\t\t\t\ttry {\n\t\t\t\t\tres.setEncoding('utf8');\n\t\t\t\t\tvar body = \"\" ;\n\t\t\t\t\tres.on('data', function (chunk) { body += chunk ; });\n\t\t\t\t\tres.on('end', function(){\n\t\t\t\t\t\tif (res.statusCode==200)\n\t\t\t\t\t\t\t$return(body) ;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar err = new Error(\"HTTP error \"+res.statusCode) ;\n\t\t\t\t\t\t\terr.body = body ;\n\t\t\t\t\t\t\terr.res = res ;\n\t\t\t\t\t\t\t$error(err) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}) ;\n\t\t\t\t} catch(ex) {\n\t\t\t\t\t$error(ex) ;\n\t\t\t\t}\n\t\t\t}).on('error',$error) ;\n\t\t}) ;\n\t};\n\t\n\treturn cover ;\n};\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/covers/map.js":"function MapError(message) {\n  Error.apply(this,arguments) ;\n  this.name = 'MapError';\n}\nMapError.prototype = Object.create(Error.prototype);\nMapError.prototype.constructor = MapError;\n\nmodule.exports = function(nodent,opts) {\n    if (!opts) opts = {} ;\n    if (!opts.Promise)\n        opts.Promise = global.Promise || nodent.Thenable ;\n\n\tfunction map(what,result,asyncFn) {\n\t\tvar hasError = false ;\n\t\tif (typeof what==\"number\") {\n\t\t\tvar period = [] ;\n\t\t\tperiod.length = Math.floor(what) ;\n\t\t\tperiod.forEach = function(fn) {\n\t\t\t\tfor (var i=0; i<period.length; i++)\n\t\t\t\t\tfn.apply(null,[i,i,period]) ;\n\t\t\t} ;\n\t\t\treturn map(period,result,asyncFn) ;\n\t\t}\n\n\t\tvar isArray = Array.isArray(what) ;\n\t\tvar context = new MapError() ;\n\t\tif (!asyncFn && (typeof result in {'function':true,'undefined':true})) {\n\t\t\tasyncFn = result ;\n\t\t\tresult = isArray?[]:{} ;\n\t\t}\n\t\tvar array = isArray?what:Object.keys(what) ;\n\t\treturn new (opts.Promise)(function ($return,$error) {\n\t\t\tvar len = array.length ;\n\t\t\tif (len==0)\n\t\t\t\treturn $return(result) ;\n\n\t\t\tarray.forEach(function(e,i,ar){\n\t\t\t\tfunction complete(r) {\n\t\t\t\t\tif (r instanceof Object && typeof r.then===\"function\")\n\t\t\t\t\t\treturn r.then(complete,completeError) ;\n\t\t\t\t\t\n\t\t\t\t\tvar k = isArray?i:e ; \n\t\t\t\t\tif (k in result) {\n\t\t\t\t\t\tcontext.message = \"nodent.map: multiple $returns/errors at \"+k ; \n\t\t\t\t\t\treturn $error(context) ;\n\t\t\t\t\t}\n\t\t\t\t\tresult[k] = r ;\n\t\t\t\t\tlen -= 1 ;\n\t\t\t\t\tif (len==0) {\n\t\t\t\t\t\tif (hasError) {\n\t\t\t\t\t\t\tcontext.message = Object.keys(hasError).map(function(e){ return e+\": \"+hasError[e].message }).join(\", \");\t\n\t\t\t\t\t\t\tcontext.results = result ;\n\t\t\t\t\t\t\treturn $error(context) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn $return(result) ;\n\t\t\t\t\t}\n\t\t\t\t\telse if (len<0) {\n\t\t\t\t\t\tcontext.message = \"nodent.map: Excess $returns/errors at \"+k ;\n\t\t\t\t\t\treturn $error(context) ;\n\t\t\t\t\t}\n\t\t\t\t} ;\n\t\t\t\tfunction completeError(x) {\n\t\t\t\t\tif (!(x instanceof Error))\n\t\t\t\t\t\tx = new Error(x) ;\n\t\t\t\t\tif (opts.throwOnError) {\n\t\t\t\t\t\thasError = hasError || {} ;\n\t\t\t\t\t\thasError[isArray?i:e] = x ;\n\t\t\t\t\t}\n\t\t\t\t\tcomplete(x) ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (asyncFn) {\n\t\t\t\t\tasyncFn.apply(this,arguments).then(complete,completeError);\t\n\t\t\t\t} else {\n\t\t\t\t\tvar f = isArray?e:what[e] ; \n\t\t\t\t\tif (nodent.isThenable(f))\n\t\t\t\t\t\tf.then(complete,completeError);\n\t\t\t\t\telse \n\t\t\t\t\t\tcomplete(f) ;\n\t\t\t\t}\n\t\t\t}) ;\n\t\t});\n\t}\n\tmap.MapError = MapError ;\n\treturn map ;\n}\n\nmodule.exports.MapError = MapError ;\n\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/covers/nodentify.js":"/* noDentify is an old routine attaached to Function.prototype in nodent <=v2.6.10\n * It is included here if users of >v3.0.0 really want it\n */\n \nmodule.exports = function(nodent,config) {\n/**\n * NoDentify (make async) a general function.\n * The format is function(a,b,cb,d,e,f){}.noDentify(cbIdx,errorIdx,resultIdx) ;\n * for example:\n * \t\thttp.aGet = http.get.noDentify(1) ;\t// The 1st argument (from zero) is the callback. errorIdx is undefined (no error)\n *\n * The function is transformed from:\n * \t\thttp.get(opts,function(result){}) ;\n * to:\n * \t\thttp.aGet(opts).then(function(result){}) ;\n *\n * @params\n * idx\t\t\tThe argument index that is the 'callback'. 'undefined' for the final parameter\n * errorIdx\t\tThe argument index of the callback that holds the error. 'undefined' for no error value\n * resultIdx \tThe argument index of the callback that holds the result.\n * \t\t\t\t'undefined' for the argument after the errorIdx (errorIdx != undefined)\n * \t\t\t\t[] returns all the arguments\n * promiseProvider\tFor promises, set this to the module providing Promises.\n */\n\treturn function noDentify(idx,errorIdx,resultIdx,promiseProvider) {\n\t\tpromiseProvider = promiseProvider || nodent.Thenable ;\n\t\tvar fn = this ;\n\t\treturn function() {\n\t\t\tvar scope = this ;\n\t\t\tvar args = Array.prototype.slice.apply(arguments) ;\n\t\t\tvar resolver = function(ok,error) {\n\t\t\t\tif (undefined==idx)\t// No index specified - use the final (unspecified) parameter\n\t\t\t\t\tidx = args.length ;\n\t\t\t\tif (undefined==errorIdx)\t// No error parameter in the callback - just pass to ok()\n\t\t\t\t\targs[idx] = ok ;\n\t\t\t\telse {\n\t\t\t\t\targs[idx] = function() {\n\t\t\t\t\t\tvar err = arguments[errorIdx] ;\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\treturn error(err) ;\n\t\t\t\t\t\tif (Array.isArray(resultIdx) && resultIdx.length===0)\n\t\t\t\t\t\t\treturn ok(arguments) ;\n\t\t\t\t\t\tvar result = arguments[resultIdx===undefined?errorIdx+1:resultIdx] ;\n\t\t\t\t\t\treturn ok(result) ;\n\t\t\t\t\t} ;\n\t\t\t\t}\n\t\t\t\treturn fn.apply(scope,args) ;\n\t\t\t}\n\t\t\treturn new promiseProvider(resolver) ;\n\t\t};\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/htmlScriptParser/index.js":"module.exports = function(nodent,html,url,options){\n\tvar f = [[],[]] ;\n\tvar re = [/(.*)(<script[^>]*>)(.*)/i,/(.*)(<\\/script>)(.*)/i] ;\n\tvar m = 0 ;\n\tvar initScript = true ;\n\thtml = html.split(\"\\n\") ;\n\n\tfor (var l=0; l<html.length; ) {\n\t\tvar fragment = re[m].exec(html[l]) ;\n\t\tif (fragment) {\n\t\t\tif (m==0 && fragment[2].match(\"src=\"))\n\t\t\t\tfragment = null ;\n\t\t} \n\t\tif (!fragment) {\n\t\t\tf[m].push(html[l++]) ;\n\t\t} else {\n\t\t\tif (m==1) {\n\t\t\t\tf[m].push(fragment[1]) ;\n\t\t\t\tpr = nodent.compile(f[1].join(\"\\n\"),url,3,options.compiler).code;\n\t\t\t\tif (initScript && options.runtime) {\n\t\t\t\t\tinitScript = false ;\n\t\t\t\t\tif (options.runtime)\n\t\t\t\t\t\tf[0].push(\"Function.prototype.$asyncbind = \"+nodent.$asyncbind.toString()+\";\\n\") ;\n\t\t\t\t}\n\t\t\t\tf[0].push(pr) ;\n\t\t\t\tf[1] = [] ;\n\t\t\t\tm = 0 ;\n\t\t\t\tf[m].push(fragment[2]) ;\n\t\t\t} else {\n\t\t\t\tf[m].push(fragment[1]) ;\n\t\t\t\tf[m].push(fragment[2]) ;\n\t\t\t\tm = 1 ;\n\t\t\t}\n\t\t\thtml[l] = fragment[3] ;\n\t\t}\n\t}\n\treturn f[0].join(\"\\n\") ;\n}\n","/home/travis/build/npmtest/node-npmtest-nodent/node_modules/nodent/lib/runtime.js":"// Now moved into its own module, but still available \n// here for anyone who referenced it as 'nodent/lib/runtime' \nmodule.exports = require('nodent-runtime');\n"}